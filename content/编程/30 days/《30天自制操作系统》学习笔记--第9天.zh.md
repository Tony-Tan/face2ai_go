---
title: 【30天自制操作系统】 内存管理
list_number: false
date: 2013-12-01 13:47
categories:
    - 30天自制操作系统
---
**Abstract:** 30天自制操作系统》内存管理
**Keywords:** 《30天自制操作系统》，Macbook，内存管理
<!--more-->
# 内存管理
对于一个系统来说，资源是最重要的，管理资源应该说就像计划你口袋里面的钱怎么花一样（不太准确。。但是重要性是相似的）。
首先是检查内存大小，BIOS应该是提供内存大小检查功能的，但是不同的BIOS查找内存大小的方式不同，所以我们应该以一种更为通用的方法进行，以获得更好的系统兼容性，而且现在的CPU都配有各种缓存，一级，二级，三级。。。先要禁止高速缓存，才能确保访问的变量全部在内存中，所以，先禁用缓存（设置CR0的某个标志位为指定值，本书还检查了一下机器是否有高速缓存，这个现在基本不用检查了，我还真就没见过386长什么样）。禁用掉高速缓存我们就要对内存挨个访问了，看看到底有没有这个位置，对0xaa55aa55的反转和比较再反转，我感觉没有什么具体意义，你可以改成任意的数字，如果访问的内存地址不存在，则返回记录到的最大的位置值，后面的程序是优化次功能程序，如果只为了检查内存的大小，完全可不用一个一个来，而是十个十个来或者一万个一万个来，只检查最后的几位就行，这个的速度会按照相应的倍数提升而准确度也会随之下降。如果要做内存健康检查就要一个一个来了。。。书中还有一个涉及到编译器的优化问题，这个会在后续的博客中详细介绍。。
接下来，检查完内存就要对内存分配进行管理了，这个应该是个很困难的问题，书中的方法有两种。
第一种：首先设置内存分配的最小单位，书中为4KB，把所有能用的字节都统计出来划分成4KB一段的好多个内存块，然后用一个字符数组来记录那些很忙，那些很闲，然后分配给需要的程序，这样的代价是每4K就需要8BIT的空间来标记这块的可用性（8/（4×1024）=1/512）所以代价是恒定的，不论多大内存N GB，都需要（N/512GB的内存来记录），这样的好处也是第二种方法的缺点就是不用做拼接，碎片问题容易解决。据说内存碎片是个很可怕的问题，尤其是对于长时间运行的服务器。。。
第二种：用一个数据结构记录所有内存的使用情况，这个数据结构内包含一个可用空间大小的记录，还有就是N个用于记录内存起始地址和可用大小的子结构数组了。。
```c++
    struct FREEINFO {
    	unsigned int addr, size;//起始地址，和大小
    };

    struct MEMMAN {
    	int frees, maxfrees, lostsize, losts;	   	//这是内存的一些记录，包括可用空间，最大可用空间，释放失败大小，释放失败的次数
    	struct FREEINFO free[MEMMAN_FREES];        	//具体的信息。。
    };
```
第二种方法速度快，占用空间小，但是分配时产生的细小的内存空间没有被使用，和回收内存时的合并操作都相当麻烦。。所以有利有弊，当内存碎片过多，而系统回收算法不够强壮时有可能是灾难性的。。
至于设计系统时用什么样的内存管理方法，目前还没想好，总之，这是个很关键的问题。。会找一些资料，在后续的博文中陆续推出，欢迎收看





