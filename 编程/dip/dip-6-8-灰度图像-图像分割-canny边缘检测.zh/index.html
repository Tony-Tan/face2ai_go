<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 | 谭升的博客</title><meta name=keywords content="canny,边缘检测"><meta name=description content="Abstract: 数字图像处理：第46天
Keywords: canny,边缘检测"><meta name=author content="谭升"><link rel=canonical href=https://go.face2ai.com/%E7%BC%96%E7%A8%8B/dip/dip-6-8-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2-canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.zh/><link crossorigin=anonymous href=../../../assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../../assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://go.face2ai.com/logo.png><link rel=icon type=image/png sizes=16x16 href=https://go.face2ai.com/logo.png><link rel=icon type=image/png sizes=32x32 href=https://go.face2ai.com/logo.png><link rel=apple-touch-icon href=https://go.face2ai.com/logo.png><link rel=mask-icon href=https://go.face2ai.com/logo.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-105335860-3","auto"),ga("send","pageview"))</script><meta property="og:title" content="【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测"><meta property="og:description" content="Abstract: 数字图像处理：第46天
Keywords: canny,边缘检测"><meta property="og:type" content="article"><meta property="og:url" content="https://go.face2ai.com/%E7%BC%96%E7%A8%8B/dip/dip-6-8-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2-canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.zh/"><meta property="article:section" content="编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测"><meta name=twitter:description content="Abstract: 数字图像处理：第46天
Keywords: canny,边缘检测"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测","item":"https://go.face2ai.com/%E7%BC%96%E7%A8%8B/dip/dip-6-8-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2-canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.zh/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测","name":"【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测","description":"Abstract: 数字图像处理：第46天 Keywords: canny,边缘检测\n","keywords":["canny","边缘检测"],"articleBody":"Abstract: 数字图像处理：第46天 Keywords: canny,边缘检测\n本文最初发表于csdn，于2018年2月17日迁移至此\n灰度图像-图像分割 Canny边缘检测 废话开始，Canny大名鼎鼎，大家都称之为Canny算子，包括wiki上也是写的Canny detector，但是按照我的理解，我觉得叫做Canny算法比较合适，但如果叫做算子，那也应该叫做复合算子，因为Canny本身并不是一个线性模板（像Sobel那样）或者一个局部比较类的算法（像中值滤波那样的），Canny是一套完整的理论，并实现出了完整的算法。 Canny是目前已知的最好的边缘检测算法，是不是之一我不确定，但可以肯定的是，它的应用非常广泛，基本用到边缘检测的，大家永远第一个想到它。Canny算法的复杂度比前面的检测加阈值的算法计算复杂度更高，空间复杂度也要高一些，但现在的计算设备，对于Canny基本可以实现实时，并且有人用GPU来实现，所以从86年Canny提出了这个算法到现在，在边缘检测方面，其地位还是比较稳固的。 Canny算法的另一个显著特征是它有完整的数学推导过程，能够证明这个算法能给出最好的边缘。后面我们将会简单的看一下数学过程。\n 算法原理 算法原理，Canny首先提出了三种基本条件，来定义一个边缘。来看原文【Canny1986】：\n  Good detection. There should be a low probability of failing to mark real edge points, and low probability of falsely marking nonedge points. Since both these probabilities are monotonically decreasing functions of the output signal-to-noise ratio, this criterion corresponds to maximizing signal-to-noise ratio. Good localization. The points marked as edge points by the operator should be as close as possible to the center of the true edge. Only one response to a single edge. This is implicitly captured in the first criterion since when there are two responses to the same edge, one of them must be considered false. However, the mathematical form of the first criterion did not capture the multiple response requirement and it had to be made explicit.   翻译一下：\n 好的检测：一定要尽可能少的遗漏边缘点，尽可能少的添加非边缘点。正确的边缘点为信号，被错误检测出来的非边缘点为噪声，所以第一点归结为提高信噪比。 准确的位置：检测出的边缘点一定要与真正的边缘中心，尽可能的近。 边缘单一响应：对于一个边缘，只能产生一个响应，如果对于一个边缘产生两个响应，第一点的数学求解过程不能保证这一点，所以要单独明确，如果对于一边有两个响应，必须去掉一个。  这就是Canny的指导思想，并且根据这一思想进行建模。\n 数学原理 发表在VOL. PAMI-8, NO. 6, NOVEMBER 1986上的文章给出了明确的求解过程，包括建模上面的理论，并求解最优解，因为本人数学功底一般，后面的求解过程有兴趣的同学可以自行查看论文，这里只给出建模上面三个基本原理的过程，以一维下的情况给出。 首先我们设滤波器的单位冲击响应为： $f(x)$ ，定义边缘本身为 $G(x)$ ，边缘中心位置为$x=0$处，滤波器响应范围 $[-w,+w]$ 边缘对滤波器的响应为： $H_G(x)=\\int_{-w}^{+w} G(-x)f(x),dx$ (1)\n噪声 $n(x)$ 相应的均方根为： $H_n=n_0[\\int_{-w}^{+w}f^2(x),dx]^{1/2}$ (2)\n其中 $n^2_0$ 是单位长度的均方噪声幅度 由上面两个式子，我们定义信噪比SNR： $SNR=\\frac{\\int_{-w}^{+w} G(-x)f(x),dx}{n_0[\\int_{-w}^{+w}f^2(x),dx]^{1/2}}$ (3)\n这便是原理1的建模，使信噪比尽可能大，来满足原理1。 为了度量检测出的边缘与实际边缘的位置关系，我们使用均方根误差距离。对于检测滤波器 $f(x)$ 我们一般认为滤波结果给出的局部最大值为检测到的边缘，所以如果没有噪声加入时响应结果的一阶导数在$x=0$处应该为0，即 $x=0$ 为对滤波器响应的局部最大值，也就是计算边界点。 设 $H_n(x)$ 只是噪声对滤波器的响应， $H_G(x)$ 只是边缘对滤波器的响应，根据上面的设想，一定有 $x=x_0$ 处满足：\n$H^{’}_n(x_0)+H^{’}_G(x_0)=0$ (4)\n泰勒展开 $H^{’}_G(x_0)$ 可以得出：\n$H^{’}_G(x_0)=H^{’}_G(0)+H^{’’}_G(0)x_0+o(x_0^2)$ (5)\n因为可以确定 $H^{’}_G(0)=0$ 结合(4)(5)可以得出：\n$H^{’’}_G(0)x_0 \\approx {-H^{’}_n(x_0)}$(6)\n$H^{’}_n(x_0)$ 为高斯随机量，并且其方差是 $H^{’}_n(x_0)$ 的均方值，并且给出其期望为：\n$E[H^{’}n(x_0)^2]=n_0^2\\int^{+w}{-w}f^{‘2}(x),dx$(7)\n将(7)和(6)结合，可以得到：\n$E[x^2_0]\\approx {\\frac{n_0^2\\int^{+w}{-w}f^{‘2}(x),dx}{[{\\int{-w}^{+w} G^{’}(-x)f^{’}(x),dx}]^2}}=\\delta x^2_0$ (8)\n$\\delta x^2_0$ 是 $x_0$ 标准差的近似，位置由其倒数给出：\n$Localization =\\frac{|\\int^{+w}{-w}G^{’}(-x)f^{’}(x),dx|}{n_0[\\int^{+w}{-w}f^{‘2}(x),dx]^{-1/2}}$(9)\n这便是原理2的建模，使信噪比尽可能大，来满足原理1。 结合原理1，原理2，我们得出为了满足前面两个基本原理，需要最大化：\n$\\frac{\\int_{-w}^{+w} G(-x)f(x),dx}{n_0[\\int_{-w}^{+w}f^2(x),dx]^{1/2}}\\frac{|\\int^{+w}{-w}G^{’}(-x)f^{’}(x),dx|}{n_0[\\int^{+w}{-w}f^{‘2}(x),dx]^{-1/2}}$(10)\n下面就是第三个原理的过程了，其与前两个原理使用的只是不太相同，根据Schwarz不等式，SNR（3）中给出的式子上边界为：\n$n^{-1}0[\\int^{+w}{-w}G^{2}(x)dx]^{1/2}$\nLocalization(9)上边界于：\n$n^{-1}0[\\int^{+w}{-w}G’^{2}(x)dx]^{1/2}$\n最大值出现在 $f(x)=G(-x)$ 其中 $x$ 属于 $[-w,+w]$ 检测点到真实点的平均距离为：\n$x_{ave}=\\pi(\\frac{-R(0)}{R^{’’}(0)})^{1/2}$(11)\n其中R是函数g的自相关：\n$R(0) = \\int ^{+\\infty}_{-\\infty}g^{2}(x),dx$\n$R^{’’}(0) = -\\int ^{+\\infty}_{-\\infty}{g’}^{2}(x),dx$\n所以 $f’$ 的零交叉平均距离为：\n$x_{zc}(f)=\\pi(\\frac{\\int ^{+\\infty}{-\\infty}f’^{2}(x),dx}{\\int ^{+\\infty}{-\\infty}{f’’}^{2}(x),dx})^{1/2}$(12)\n对于 $f$ 的最大噪声响应 $x_{max}$ 定义为两倍 $x_{zc}$ 我们定义其为滤波器宽度的k倍\n$x_{max}(f)=2x_{zc}(f)=kW$(13)\n所以噪声最大的数量在 $N_n$ 区域内：\n$N_n=\\frac{2W}{x_{max}}=\\frac{2}{k}$(14)\n数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。 算法过程 算法过程比较容易：\n 高斯平滑，采用$5 \\times5$的高斯滤波器对图像进行平滑。 使用Sobel算子检测边缘候选点，计算梯度方向，得到简化的梯度方向。 非极大值抑制，减少多重响应。 边缘跟踪，采用双阈值处理候选点。 形态学细化，对于有些较粗的边界采用形态学方法处理。  具体解析： 第一步：高斯平滑，Canny的核心检测算子是Sobel算子，所以。Canny如果按照算子划分的话属于一阶微分算子，所以它具有一阶微分算子的特性，对噪声敏感，所以，我们的第一步就是降低噪声，使用高斯平滑降低噪声，冈萨雷斯书上介绍说Canny证明高斯平滑是最好的平滑算子，这一点我并未查证，但根据高斯函数的频域特性可知，它没有振铃，而且当频率值超过 $3\\times \\delta$ 时基本趋近于零，所以可以当做一种完美的滤波器（以上这句话是我猜测的，没有理论根据），此步骤的主要目的–降噪 第二步：Sobel边缘检测，此处为检测边缘候选点，并计算出候选点梯度的过程，其中Sobel可选大小为3x3，5x5，7x7或者-1，其中-1表示为Scharr算子，这个在前文已经比较过了Sobel和Scharr的性能，在这里不再解释 第三步：局部非极大值抑制，俗话就是找局部最大值，寻找方法是得出每个候选点的梯度方向，沿着梯度方向和梯度反方向比较相邻的元素，如果候选点是三个中最大的，则保留，否则，置零。 第四步：双阈值滞后滤波，这里的滞后滤波应该是比较难以理解的，我们分别设置两个阈值，大阈值和小阈值之间比例大于为3：1或2：1，这里的方法是:\n 1. 输入候选点灰度值 2. 判断是否大于大阈值，如果大于则到第4步 2. 判断是否大于小阈值，如果小于则到第5步 3. 判断该点是否连通于边缘点，不是则到第5步 4. 此点为边缘点，到第6步 5. 此点非边缘点 6. 如果图像还有未处理候选边缘像素，返回第1步，否则结束 双阈值滞后处理是Canny的核心部分，下面给出双阈值的阈值传递函数： 上图说明只有的时滞后阈值的传递函数，解释下就是如果一个候选点大于高阈值，那么它肯定是边缘点，如果大于小阈值，则需要它连通到边缘点。 我们在算法实现时使用方法是，先找到所有大于大阈值的点的集合H，H全部为边缘点，然后找出所有大于小阈值的点的集合L，其中L包含所有的H，那么以H中的每个点为种子点，以八邻域遍历L，被遍历到的为边缘点，未被遍历的为非边缘点。这里的遍历与图的遍历相同，可以使用深度优先或广度优先。\n第五步：细化结果，有时一个边缘会产生两个等价的边缘点，使用细化可以得到单像素边缘，但需注意，这两个点都是正确的点，选其中任意一个都是正确的。\n代码实现 /* * 四个角度对应编号 * 0 1 2 * 3 * 5 * 6 7 8 * edgedirction */ void getEdgeDirection(double *edgedirection,double *sample_direction,int width,int height){ double angle=0.0; for(int i=0;iwidth*height;i++){ angle=edgedirection[i]; if(angle22.5||angle=337.5) sample_direction[i]=5.0; else if(angle67.5\u0026\u0026angle=22.5) sample_direction[i]=2.0; else if(angle112.5\u0026\u0026angle=67.5) sample_direction[i]=1.0; else if(angle157.5\u0026\u0026angle=112.5) sample_direction[i]=0.0; else if(angle202.5\u0026\u0026angle=157.5) sample_direction[i]=3.0; else if(angle247.5\u0026\u0026angle=202.5) sample_direction[i]=6.0; else if(angle292.5\u0026\u0026angle=247.5) sample_direction[i]=7.0; else if(angle337.5\u0026\u0026angle=292.5) sample_direction[i]=8.0; else if(angle==-1.0) sample_direction[i]=-1.0; } } /* * 四个角度对应编号 * 0 1 2 * 3 * 5 * 6 7 8 * */ void Non_MaxSuppression(double *src,double *dst,double *dirction,int width,int height){ double *temp=(double*)malloc(sizeof(double)*width*height); int dir; int y; int x; double value_c; Zero(temp, width, height); for(int j=1;jheight-1;j++) for(int i=1;iwidth-1;i++){ if(dirction[j*width+i]!=-1.0){ dir=(int)dirction[j*width+i]; y=dir/3-1; x=dir%3-1; value_c=src[j*width+i]; if(value_csrc[(j+y)*width+i+x]||value_csrc[(j-y)*width+i-x]) temp[j*width+i]=0.0; else temp[j*width+i]=value_c; } } matrixCopy(temp, dst, width, height); free(temp); } void EdgeTrack(double *src,int width,int height,Position *seed){ int x=seed-x; int y=seed-y; if(x=0\u0026\u0026xwidth\u0026\u0026y=0\u0026\u0026yheight\u0026\u0026src[y*width+x]==1.0){ src[y*width+x]=2; for(int j=-1;j2;j++) for(int i=-1;i2;i++){ if(!(j==0\u0026\u0026i==0)){ Position seed_next; seed_next.x=x+i; seed_next.y=y+j; EdgeTrack(src,width,height,\u0026seed_next); } } } } void NonZeroSetOne(double *src,double *dst,int width,int height){ for(int i=0;iwidth*height;i++) dst[i]=src[i]!=0.0?1.0:0.0; } void Canny(double *src,double *dst,int width,int height,int sobel_size,double threshold1,double threshold2){ double *temp=(double *)malloc(sizeof(double)*width*height); double *edge_a=(double *)malloc(sizeof(double)*width*height);//边缘幅度  double *edge_d=(double *)malloc(sizeof(double)*width*height);//边缘方向  double *threshold_max=(double *)malloc(sizeof(double)*width*height); double *threshold_min=(double *)malloc(sizeof(double)*width*height); /* *step1:gaussian smooth */ double gaussianmask[25]={ 2, 4, 5, 4, 2, 4, 9,12, 9, 4, 5,12,15,12, 5, 4, 9,12, 9, 4, 2, 4, 5, 4, 2}; RealConvolution(src, temp, gaussianmask, width, height, 5, 5); matrixMultreal(temp, temp, 1.0/159.0, width, height); /* *step2:sobel */ if(sobel_size==3) Scharr(temp, edge_a, edge_d, width, height); else if(sobel_size==5||sobel_size==7) Sobel(temp, edge_a, edge_d, width, height,sobel_size); /* *step3:Non_MaxSuppression */ getEdgeDirection(edge_d, edge_d, width, height); Non_MaxSuppression(edge_a, temp, edge_d, width, height); /* *step4:double threshold */ Threshold(temp, threshold_max, width, height, threshold1, MORETHAN); Threshold(temp, threshold_min, width, height, threshold2, MORETHAN); NonZeroSetOne(threshold_max,threshold_max,width,height); NonZeroSetOne(threshold_min,threshold_min,width,height); for(int j=0;jheight;j++){ for(int i=0;iwidth;i++){ if(threshold_max[j*width+i]==1.0\u0026\u0026threshold_min[j*width+i]!=2.0){ Position p; p.x=i; p.y=j; EdgeTrack(threshold_min, width, height, \u0026p); } } } /* *step5:result */ Zero(dst, width, height); for(int i=0;iwidth*height;i++) if(threshold_min[i]==2.0) dst[i]=255.0; free(temp); free(threshold_max); free(threshold_min); free(edge_d); free(edge_a); } 实现结果 实验每步结果： 原图： STEP1： STEP2： Sobel梯度幅度结果： Sobel梯度方向结果： STEP3： STEP4：  原图： STEP1： STEP2： Sobel梯度幅度结果：\nSobel梯度方向结果： STEP3： STEP4： 总结 总结，Canny实现起来算法过程并不难，可能进一步优化加速就需要一些难度了，冈萨雷斯书中提到，第四步滞后阈值可以和第三步非极大值抑制放在一起。 待续。。。。\n","wordCount":"601","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"谭升"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://go.face2ai.com/%E7%BC%96%E7%A8%8B/dip/dip-6-8-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2-canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B.zh/"},"publisher":{"@type":"Organization","name":"谭升的博客","logo":{"@type":"ImageObject","url":"https://go.face2ai.com/logo.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://go.face2ai.com accesskey=h title="谭升的博客 (Alt + H)">谭升的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://go.face2ai.com/math/ title=数学><span>数学</span></a></li><li><a href=https://go.face2ai.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://go.face2ai.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://go.face2ai.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://go.face2ai.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://go.face2ai.com>Home</a></div><h1 class=post-title>【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测</h1><div class=post-meta>谭升</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2-canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="灰度图像-图像分割 Canny边缘检测">灰度图像-图像分割 Canny边缘检测</a><ul><li><a href=#%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86 aria-label=算法原理>算法原理</a></li><li><a href=#%e6%95%b0%e5%ad%a6%e5%8e%9f%e7%90%86 aria-label=数学原理>数学原理</a></li><li><a href=#%e6%95%b0%e5%ad%a6%e5%bb%ba%e6%a8%a1%e5%a4%a7%e6%a6%82%e5%a6%82%e4%b8%8a%e5%8f%af%e8%83%bd%e7%9c%8b%e4%b8%8d%e6%87%82%e4%bd%86%e6%98%af%e6%b2%a1%e5%85%b3%e7%b3%bb%e5%9b%a0%e4%b8%ba%e8%bf%99%e5%b9%b6%e4%b8%8d%e5%bd%b1%e5%93%8d%e6%88%91%e4%bb%ac%e5%af%b9%e7%ae%97%e6%b3%95%e8%bf%87%e7%a8%8b%e7%9a%84%e7%90%86%e8%a7%a3 aria-label=数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。>数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。</a></li><li><a href=#%e7%ae%97%e6%b3%95%e8%bf%87%e7%a8%8b aria-label=算法过程>算法过程</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-label=代码实现>代码实现</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e7%bb%93%e6%9e%9c aria-label=实现结果>实现结果</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></div></details></div><div class=post-content><p><strong>Abstract:</strong> 数字图像处理：第46天
<strong>Keywords:</strong> canny,边缘检测</p><p><font color=00FF00>本文最初发表于csdn，于2018年2月17日迁移至此</font></p><h1 id=灰度图像-图像分割-canny边缘检测>灰度图像-图像分割 Canny边缘检测<a hidden class=anchor aria-hidden=true href=#灰度图像-图像分割-canny边缘检测>#</a></h1><p>废话开始，Canny大名鼎鼎，大家都称之为Canny算子，包括wiki上也是写的Canny detector，但是按照我的理解，我觉得叫做Canny算法比较合适，但如果叫做算子，那也应该叫做复合算子，因为Canny本身并不是一个线性模板（像Sobel那样）或者一个局部比较类的算法（像中值滤波那样的），Canny是一套完整的理论，并实现出了完整的算法。
Canny是目前已知的最好的边缘检测算法，是不是之一我不确定，但可以肯定的是，它的应用非常广泛，基本用到边缘检测的，大家永远第一个想到它。Canny算法的复杂度比前面的<strong>检测加阈值</strong>的算法计算复杂度更高，空间复杂度也要高一些，但现在的计算设备，对于Canny基本可以实现实时，并且有人用GPU来实现，所以从86年Canny提出了这个算法到现在，在边缘检测方面，其地位还是比较稳固的。
Canny算法的另一个显著特征是它有完整的数学推导过程，能够证明这个算法能给出最好的边缘。后面我们将会简单的看一下数学过程。</p><hr><h2 id=算法原理>算法原理<a hidden class=anchor aria-hidden=true href=#算法原理>#</a></h2><p>算法原理，Canny首先提出了三种基本条件，来定义一个边缘。来看原文【Canny1986】：</p><blockquote><ol><li>Good detection. There should be a low probability of failing to mark real edge points, and low probability of falsely marking nonedge points. Since both these probabilities are monotonically decreasing functions of the output signal-to-noise ratio, this criterion corresponds to maximizing signal-to-noise ratio.</li><li>Good localization. The points marked as edge points by the operator should be as close as possible to the center of the true edge.</li><li>Only one response to a single edge. This is implicitly captured in the first criterion since when there are two responses to the same edge, one of them must be considered false. However, the mathematical form of the first criterion did not capture the multiple response requirement and it had to be made explicit.</li></ol></blockquote><p>翻译一下：</p><ol><li>好的检测：一定要尽可能少的遗漏边缘点，尽可能少的添加非边缘点。正确的边缘点为信号，被错误检测出来的非边缘点为噪声，所以第一点归结为提高信噪比。</li><li>准确的位置：检测出的边缘点一定要与真正的边缘中心，尽可能的近。</li><li>边缘单一响应：对于一个边缘，只能产生一个响应，如果对于一个边缘产生两个响应，第一点的数学求解过程不能保证这一点，所以要单独明确，如果对于一边有两个响应，必须去掉一个。</li></ol><p>这就是Canny的指导思想，并且根据这一思想进行建模。</p><hr><h2 id=数学原理>数学原理<a hidden class=anchor aria-hidden=true href=#数学原理>#</a></h2><p>发表在VOL. PAMI-8, NO. 6, NOVEMBER 1986上的文章给出了明确的求解过程，包括建模上面的理论，并求解最优解，因为本人数学功底一般，后面的求解过程有兴趣的同学可以自行查看论文，这里只给出建模上面三个基本原理的过程，以一维下的情况给出。
首先我们设滤波器的单位冲击响应为： $f(x)$ ，定义边缘本身为 $G(x)$ ，边缘中心位置为$x=0$处，滤波器响应范围 $[-w,+w]$
边缘对滤波器的响应为：
$H_G(x)=\int_{-w}^{+w} G(-x)f(x),dx$ (1)</p><p>噪声 $n(x)$ 相应的均方根为：
$H_n=n_0[\int_{-w}^{+w}f^2(x),dx]^{1/2}$ (2)</p><p>其中 $n^2_0$ 是单位长度的均方噪声幅度
由上面两个式子，我们定义信噪比SNR：
$SNR=\frac{\int_{-w}^{+w} G(-x)f(x),dx}{n_0[\int_{-w}^{+w}f^2(x),dx]^{1/2}}$ (3)</p><p>这便是原理1的建模，使信噪比尽可能大，来满足原理1。
为了度量检测出的边缘与实际边缘的位置关系，我们使用均方根误差距离。对于检测滤波器 $f(x)$ 我们一般认为滤波结果给出的局部最大值为检测到的边缘，所以如果没有噪声加入时响应结果的一阶导数在$x=0$处应该为0，即 $x=0$ 为对滤波器响应的局部最大值，也就是计算边界点。
设 $H_n(x)$ 只是噪声对滤波器的响应， $H_G(x)$ 只是边缘对滤波器的响应，根据上面的设想，一定有 $x=x_0$ 处满足：</p><p>$H^{&rsquo;}_n(x_0)+H^{&rsquo;}_G(x_0)=0$ (4)</p><p>泰勒展开 $H^{&rsquo;}_G(x_0)$ 可以得出：</p><p>$H^{&rsquo;}_G(x_0)=H^{&rsquo;}_G(0)+H^{&rsquo;&rsquo;}_G(0)x_0+o(x_0^2)$ (5)</p><p>因为可以确定 $H^{&rsquo;}_G(0)=0$ 结合(4)(5)可以得出：</p><p>$H^{&rsquo;&rsquo;}_G(0)x_0 \approx {-H^{&rsquo;}_n(x_0)}$(6)</p><p>$H^{&rsquo;}_n(x_0)$ 为高斯随机量，并且其方差是 $H^{&rsquo;}_n(x_0)$ 的均方值，并且给出其期望为：</p><p>$E[H^{&rsquo;}<em>n(x_0)^2]=n_0^2\int^{+w}</em>{-w}f^{&lsquo;2}(x),dx$(7)</p><p>将(7)和(6)结合，可以得到：</p><p>$E[x^2_0]\approx {\frac{n_0^2\int^{+w}<em>{-w}f^{&lsquo;2}(x),dx}{[{\int</em>{-w}^{+w} G^{&rsquo;}(-x)f^{&rsquo;}(x),dx}]^2}}=\delta x^2_0$ (8)</p><p>$\delta x^2_0$ 是 $x_0$ 标准差的近似，位置由其倒数给出：</p><p>$Localization =\frac{|\int^{+w}<em>{-w}G^{&rsquo;}(-x)f^{&rsquo;}(x),dx|}{n_0[\int^{+w}</em>{-w}f^{&lsquo;2}(x),dx]^{-1/2}}$(9)</p><p>这便是原理2的建模，使信噪比尽可能大，来满足原理1。
结合原理1，原理2，我们得出为了满足前面两个基本原理，需要最大化：</p><p>$\frac{\int_{-w}^{+w} G(-x)f(x),dx}{n_0[\int_{-w}^{+w}f^2(x),dx]^{1/2}}\frac{|\int^{+w}<em>{-w}G^{&rsquo;}(-x)f^{&rsquo;}(x),dx|}{n_0[\int^{+w}</em>{-w}f^{&lsquo;2}(x),dx]^{-1/2}}$(10)</p><p>下面就是第三个原理的过程了，其与前两个原理使用的只是不太相同，根据Schwarz不等式，SNR（3）中给出的式子上边界为：</p><p>$n^{-1}<em>0[\int^{+w}</em>{-w}G^{2}(x)dx]^{1/2}$</p><p>Localization(9)上边界于：</p><p>$n^{-1}<em>0[\int^{+w}</em>{-w}G&rsquo;^{2}(x)dx]^{1/2}$</p><p>最大值出现在 $f(x)=G(-x)$ 其中 $x$ 属于 $[-w,+w]$
检测点到真实点的平均距离为：</p><p>$x_{ave}=\pi(\frac{-R(0)}{R^{&rsquo;&rsquo;}(0)})^{1/2}$(11)</p><p>其中R是函数g的自相关：</p><p>$R(0) = \int ^{+\infty}_{-\infty}g^{2}(x),dx$</p><p>$R^{&rsquo;&rsquo;}(0) = -\int ^{+\infty}_{-\infty}{g&rsquo;}^{2}(x),dx$</p><p>所以 $f&rsquo;$ 的零交叉平均距离为：</p><p>$x_{zc}(f)=\pi(\frac{\int ^{+\infty}<em>{-\infty}f&rsquo;^{2}(x),dx}{\int ^{+\infty}</em>{-\infty}{f&rsquo;&rsquo;}^{2}(x),dx})^{1/2}$(12)</p><p>对于 $f$ 的最大噪声响应 $x_{max}$ 定义为两倍 $x_{zc}$ 我们定义其为滤波器宽度的k倍</p><p>$x_{max}(f)=2x_{zc}(f)=kW$(13)</p><p>所以噪声最大的数量在 $N_n$ 区域内：</p><p>$N_n=\frac{2W}{x_{max}}=\frac{2}{k}$(14)</p><h2 id=数学建模大概如上可能看不懂但是没关系因为这并不影响我们对算法过程的理解>数学建模大概如上，可能看不懂，但是没关系，因为这并不影响我们对算法过程的理解。<a hidden class=anchor aria-hidden=true href=#数学建模大概如上可能看不懂但是没关系因为这并不影响我们对算法过程的理解>#</a></h2><h2 id=算法过程>算法过程<a hidden class=anchor aria-hidden=true href=#算法过程>#</a></h2><p>算法过程比较容易：</p><ol><li>高斯平滑，采用$5 \times5$的高斯滤波器对图像进行平滑。</li><li>使用Sobel算子检测边缘候选点，计算梯度方向，得到简化的梯度方向。</li><li>非极大值抑制，减少多重响应。</li><li>边缘跟踪，采用双阈值处理候选点。</li><li>形态学细化，对于有些较粗的边界采用形态学方法处理。</li></ol><p>具体解析：
第一步：高斯平滑，Canny的核心检测算子是Sobel算子，所以。Canny如果按照算子划分的话属于一阶微分算子，所以它具有一阶微分算子的特性，对噪声敏感，所以，我们的第一步就是降低噪声，使用高斯平滑降低噪声，冈萨雷斯书上介绍说Canny证明高斯平滑是最好的平滑算子，这一点我并未查证，但根据高斯函数的频域特性可知，它没有振铃，而且当频率值超过 $3\times \delta$ 时基本趋近于零，所以可以当做一种完美的滤波器（以上这句话是我猜测的，没有理论根据），此步骤的主要目的&ndash;降噪
第二步：Sobel边缘检测，此处为检测边缘候选点，并计算出候选点梯度的过程，其中Sobel可选大小为3x3，5x5，7x7或者-1，其中-1表示为Scharr算子，这个在前文已经比较过了Sobel和Scharr的性能，在这里不再解释
第三步：局部非极大值抑制，俗话就是找局部最大值，寻找方法是得出每个候选点的梯度方向，沿着梯度方向和梯度反方向比较相邻的元素，如果候选点是三个中最大的，则保留，否则，置零。
第四步：双阈值滞后滤波，这里的滞后滤波应该是比较难以理解的，我们分别设置两个阈值，大阈值和小阈值之间比例大于为3：1或2：1，这里的方法是:</p><pre tabindex=0><code> 1. 输入候选点灰度值
 2. 判断是否大于大阈值，如果大于则到第4步
 2. 判断是否大于小阈值，如果小于则到第5步
 3. 判断该点是否连通于边缘点，不是则到第5步
 4. 此点为边缘点，到第6步
 5. 此点非边缘点
 6. 如果图像还有未处理候选边缘像素，返回第1步，否则结束
</code></pre><p>双阈值滞后处理是Canny的核心部分，下面给出双阈值的阈值传递函数：
<img loading=lazy src=./20150212181022310.jpeg alt></p><p>上图说明只有的时滞后阈值的传递函数，解释下就是如果一个候选点大于高阈值，那么它肯定是边缘点，如果大于小阈值，则需要它连通到边缘点。
我们在算法实现时使用方法是，先找到所有大于大阈值的点的集合H，H全部为边缘点，然后找出所有大于小阈值的点的集合L，其中L包含所有的H，那么以H中的每个点为种子点，以八邻域遍历L，被遍历到的为边缘点，未被遍历的为非边缘点。这里的遍历与图的遍历相同，可以使用深度优先或广度优先。</p><p>第五步：细化结果，有时一个边缘会产生两个等价的边缘点，使用细化可以得到单像素边缘，但需注意，这两个点都是正确的点，选其中任意一个都是正确的。</p><h2 id=代码实现>代码实现<a hidden class=anchor aria-hidden=true href=#代码实现>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *   四个角度对应编号
</span></span></span><span class=line><span class=cl><span class=cm> *   0 1 2
</span></span></span><span class=line><span class=cl><span class=cm> *   3 * 5
</span></span></span><span class=line><span class=cl><span class=cm> *   6 7 8
</span></span></span><span class=line><span class=cl><span class=cm> *   edgedirction
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getEdgeDirection</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=n>edgedirection</span><span class=p>,</span><span class=kt>double</span> <span class=o>*</span><span class=n>sample_direction</span><span class=p>,</span><span class=kt>int</span> <span class=n>width</span><span class=p>,</span><span class=kt>int</span> <span class=n>height</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>angle</span><span class=o>=</span><span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>angle</span><span class=o>=</span><span class=n>edgedirection</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>22.5</span><span class=o>||</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>337.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>5.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>67.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>22.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>2.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>112.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>67.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>1.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>157.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>112.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>202.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>157.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>3.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>247.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>202.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>6.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>292.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>247.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>7.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>&lt;</span><span class=mf>337.5</span><span class=o>&amp;&amp;</span><span class=n>angle</span><span class=o>&gt;=</span><span class=mf>292.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>8.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>angle</span><span class=o>==-</span><span class=mf>1.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sample_direction</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=-</span><span class=mf>1.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *   四个角度对应编号
</span></span></span><span class=line><span class=cl><span class=cm> *   0 1 2
</span></span></span><span class=line><span class=cl><span class=cm> *   3 * 5
</span></span></span><span class=line><span class=cl><span class=cm> *   6 7 8
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Non_MaxSuppression</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span><span class=kt>double</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span><span class=kt>double</span> <span class=o>*</span><span class=n>dirction</span><span class=p>,</span><span class=kt>int</span> <span class=n>width</span><span class=p>,</span><span class=kt>int</span> <span class=n>height</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=o>*</span><span class=n>temp</span><span class=o>=</span><span class=p>(</span><span class=kt>double</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>dir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>value_c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Zero</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>height</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>width</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>dirction</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>]</span><span class=o>!=-</span><span class=mf>1.0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dir</span><span class=o>=</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>dirction</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>y</span><span class=o>=</span><span class=n>dir</span><span class=o>/</span><span class=mi>3</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>x</span><span class=o>=</span><span class=n>dir</span><span class=o>%</span><span class=mi>3</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>value_c</span><span class=o>=</span><span class=n>src</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>value_c</span><span class=o>&lt;=</span><span class=n>src</span><span class=p>[(</span><span class=n>j</span><span class=o>+</span><span class=n>y</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=o>+</span><span class=n>x</span><span class=p>]</span><span class=o>||</span><span class=n>value_c</span><span class=o>&lt;</span><span class=n>src</span><span class=p>[(</span><span class=n>j</span><span class=o>-</span><span class=n>y</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=o>-</span><span class=n>x</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                    <span class=n>temp</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>temp</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>value_c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>matrixCopy</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>dst</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>EdgeTrack</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span><span class=kt>int</span> <span class=n>width</span><span class=p>,</span><span class=kt>int</span> <span class=n>height</span><span class=p>,</span><span class=n>Position</span> <span class=o>*</span><span class=n>seed</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=o>=</span><span class=n>seed</span><span class=o>-&gt;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>y</span><span class=o>=</span><span class=n>seed</span><span class=o>-&gt;</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>x</span><span class=o>&gt;=</span><span class=mi>0</span><span class=o>&amp;&amp;</span><span class=n>x</span><span class=o>&lt;</span><span class=n>width</span><span class=o>&amp;&amp;</span><span class=n>y</span><span class=o>&gt;=</span><span class=mi>0</span><span class=o>&amp;&amp;</span><span class=n>y</span><span class=o>&lt;</span><span class=n>height</span><span class=o>&amp;&amp;</span><span class=n>src</span><span class=p>[</span><span class=n>y</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>x</span><span class=p>]</span><span class=o>==</span><span class=mf>1.0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>src</span><span class=p>[</span><span class=n>y</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>x</span><span class=p>]</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=-</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>j</span><span class=o>==</span><span class=mi>0</span><span class=o>&amp;&amp;</span><span class=n>i</span><span class=o>==</span><span class=mi>0</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>                    <span class=n>Position</span> <span class=n>seed_next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>seed_next</span><span class=p>.</span><span class=n>x</span><span class=o>=</span><span class=n>x</span><span class=o>+</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>seed_next</span><span class=p>.</span><span class=n>y</span><span class=o>=</span><span class=n>y</span><span class=o>+</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>EdgeTrack</span><span class=p>(</span><span class=n>src</span><span class=p>,</span><span class=n>width</span><span class=p>,</span><span class=n>height</span><span class=p>,</span><span class=o>&amp;</span><span class=n>seed_next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>NonZeroSetOne</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span><span class=kt>double</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span><span class=kt>int</span> <span class=n>width</span><span class=p>,</span><span class=kt>int</span> <span class=n>height</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>dst</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=n>src</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>!=</span><span class=mf>0.0</span><span class=o>?</span><span class=mf>1.0</span><span class=o>:</span><span class=mf>0.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Canny</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span><span class=kt>double</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span><span class=kt>int</span> <span class=n>width</span><span class=p>,</span><span class=kt>int</span> <span class=n>height</span><span class=p>,</span><span class=kt>int</span> <span class=n>sobel_size</span><span class=p>,</span><span class=kt>double</span> <span class=n>threshold1</span><span class=p>,</span><span class=kt>double</span> <span class=n>threshold2</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=o>*</span><span class=n>temp</span><span class=o>=</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=o>*</span><span class=n>edge_a</span><span class=o>=</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>);</span><span class=c1>//边缘幅度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=o>*</span><span class=n>edge_d</span><span class=o>=</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>);</span><span class=c1>//边缘方向
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=o>*</span><span class=n>threshold_max</span><span class=o>=</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=o>*</span><span class=n>threshold_min</span><span class=o>=</span><span class=p>(</span><span class=kt>double</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=o>*</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *step1:gaussian smooth
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>gaussianmask</span><span class=p>[</span><span class=mi>25</span><span class=p>]</span><span class=o>=</span><span class=p>{</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span><span class=mi>12</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=mi>5</span><span class=p>,</span><span class=mi>12</span><span class=p>,</span><span class=mi>15</span><span class=p>,</span><span class=mi>12</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span><span class=mi>12</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                              <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>RealConvolution</span><span class=p>(</span><span class=n>src</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>gaussianmask</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>matrixMultreal</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=mf>1.0</span><span class=o>/</span><span class=mf>159.0</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *step2:sobel
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>sobel_size</span><span class=o>==</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Scharr</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>edge_a</span><span class=p>,</span> <span class=n>edge_d</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>sobel_size</span><span class=o>==</span><span class=mi>5</span><span class=o>||</span><span class=n>sobel_size</span><span class=o>==</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Sobel</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>edge_a</span><span class=p>,</span> <span class=n>edge_d</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>,</span><span class=n>sobel_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *step3:Non_MaxSuppression
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>    <span class=n>getEdgeDirection</span><span class=p>(</span><span class=n>edge_d</span><span class=p>,</span> <span class=n>edge_d</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Non_MaxSuppression</span><span class=p>(</span><span class=n>edge_a</span><span class=p>,</span> <span class=n>temp</span><span class=p>,</span> <span class=n>edge_d</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *step4:double threshold
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>    <span class=n>Threshold</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>threshold_max</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>,</span> <span class=n>threshold1</span><span class=p>,</span> <span class=n>MORETHAN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Threshold</span><span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=n>threshold_min</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>,</span> <span class=n>threshold2</span><span class=p>,</span> <span class=n>MORETHAN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>NonZeroSetOne</span><span class=p>(</span><span class=n>threshold_max</span><span class=p>,</span><span class=n>threshold_max</span><span class=p>,</span><span class=n>width</span><span class=p>,</span><span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>NonZeroSetOne</span><span class=p>(</span><span class=n>threshold_min</span><span class=p>,</span><span class=n>threshold_min</span><span class=p>,</span><span class=n>width</span><span class=p>,</span><span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>height</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>width</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>threshold_max</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>]</span><span class=o>==</span><span class=mf>1.0</span><span class=o>&amp;&amp;</span><span class=n>threshold_min</span><span class=p>[</span><span class=n>j</span><span class=o>*</span><span class=n>width</span><span class=o>+</span><span class=n>i</span><span class=p>]</span><span class=o>!=</span><span class=mf>2.0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>Position</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=o>=</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>EdgeTrack</span><span class=p>(</span><span class=n>threshold_min</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> *step5:result
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>    <span class=n>Zero</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>width</span><span class=o>*</span><span class=n>height</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>threshold_min</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>==</span><span class=mf>2.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>dst</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mf>255.0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>threshold_max</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>threshold_min</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>edge_d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>edge_a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=实现结果>实现结果<a hidden class=anchor aria-hidden=true href=#实现结果>#</a></h2><p>实验每步结果：
原图：
<img loading=lazy src=./20150212181924413.jpeg alt></p><p>STEP1：
<img loading=lazy src=./20150212181937158.jpeg alt></p><p>STEP2：
Sobel梯度幅度结果：
<img loading=lazy src=./20150212181953180.jpeg alt></p><p>Sobel梯度方向结果：
<img loading=lazy src=./20150212182006783.jpeg alt></p><p>STEP3：
<img loading=lazy src=./20150212182025625.jpeg alt></p><p>STEP4：
<img loading=lazy src=./20150212182315899.jpeg alt></p><hr><p>原图：
<img loading=lazy src=./20150212182333621.jpeg alt></p><p>STEP1：
<img loading=lazy src=./20150212182345025.jpeg alt></p><p>STEP2：
Sobel梯度幅度结果：</p><p><img loading=lazy src=./20150212182356134.jpeg alt></p><p>Sobel梯度方向结果：
<img loading=lazy src=./20150212182416318.jpeg alt></p><p>STEP3：
<img loading=lazy src=./20150212182426040.jpeg alt></p><p>STEP4：
<img loading=lazy src=./20150212182449655.jpeg alt></p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>总结，Canny实现起来算法过程并不难，可能进一步优化加速就需要一些难度了，冈萨雷斯书中提到，第四步滞后阈值可以和第三步非极大值抑制放在一起。
待续。。。。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://go.face2ai.com/tags/canny/>canny</a></li><li><a href=https://go.face2ai.com/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/>边缘检测</a></li></ul><nav class=paginav><a class=prev href=https://go.face2ai.com/%E7%BC%96%E7%A8%8B/dip/dip-6-7-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2-%E7%AE%97%E5%AD%90%E5%B9%B3%E6%BB%91%E8%83%BD%E5%8A%9B%E6%AF%94%E8%BE%83.zh/><span class=title>« Prev</span><br><span>【数字图像处理】6.7:灰度图像-图像分割 Sobel算子，Prewitt算子和Scharr算子平滑能力比较</span></a>
<a class=next href=https://go.face2ai.com/%E7%BC%96%E7%A8%8B/dip/dip-6-9-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2-marr-hildreth%E7%AE%97%E5%AD%90-log%E7%AE%97%E5%AD%90.zh/><span class=title>Next »</span><br><span>【数字图像处理】6.9:灰度图像-图像分割 Marr-Hildreth算子（LoG算子）</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 on twitter" href="https://twitter.com/intent/tweet/?text=%e3%80%90%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e3%80%916.8%3a%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%20Canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b&url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f&hashtags=canny%2c%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f&title=%e3%80%90%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e3%80%916.8%3a%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%20Canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b&summary=%e3%80%90%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e3%80%916.8%3a%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%20Canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b&source=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f&title=%e3%80%90%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e3%80%916.8%3a%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%20Canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 on whatsapp" href="https://api.whatsapp.com/send?text=%e3%80%90%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e3%80%916.8%3a%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%20Canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%20-%20https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 【数字图像处理】6.8:灰度图像-图像分割 Canny边缘检测 on telegram" href="https://telegram.me/share/url?text=%e3%80%90%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e3%80%916.8%3a%e7%81%b0%e5%ba%a6%e5%9b%be%e5%83%8f-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%20Canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b&url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2fdip%2fdip-6-8-%25E7%2581%25B0%25E5%25BA%25A6%25E5%259B%25BE%25E5%2583%258F-%25E5%259B%25BE%25E5%2583%258F%25E5%2588%2586%25E5%2589%25B2-canny%25E8%25BE%25B9%25E7%25BC%2598%25E6%25A3%2580%25E6%25B5%258B.zh%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://go.face2ai.com>谭升的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>