<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>30天自制操作系统 | 谭升的博客</title><meta name=keywords content><meta name=description content="30天自制操作系统1 Mac下工具的使用 现在来介绍官网上下的工具怎么用首先是官网地址，书上有个注释上有:hrb.osask.jp 翻译成中文大概是这个样子滴。
上面有两个文件可以下载，一个是工具，一个是工具的源代码，很好的学习资料
下面把工具复制出来
看到很多可执行文件。。感觉好舒服。。
然后把我们随便一个project复制到z_tools的同级目录下
project的内容可以修改，因为批处理可以下岗了：
然后可能是难度最大的部分出现了:修改makefile
如果没用过makefile可以先找点资料看看。很简单的语法，很强大的功能： 修改完成后是：
 TOOLPATH = ../z_tools/ INCPATH = ../z_tools/haribote/ ################################################### MAKE = make NASK = $(TOOLPATH)nask CC1 = $(TOOLPATH)gocc1 -I$(INCPATH) -Os -Wall -quiet GAS2NASK = $(TOOLPATH)gas2nask -a OBJ2BIM = $(TOOLPATH)obj2bim BIM2HRB = $(TOOLPATH)bim2hrb RULEFILE = $(TOOLPATH)haribote/haribote.rul EDIMG = $(TOOLPATH)edimg IMGTOL = $(TOOLPATH)imgtol.com COPY = cp DEL = rm ################################################### ## ÉfÉtÉHÉãÉgìÆçÏ default : $(MAKE) img ## ÉtÉ@ÉCÉãê∂ê¨ãKë• ipl10.bin : ipl10.nas Makefile $(NASK) ipl10."><meta name=author content="谭升"><link rel=canonical href=https://go.face2ai.com/%E7%BC%96%E7%A8%8B/30-days/30_days_system/><link crossorigin=anonymous href=../../../assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../../assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://go.face2ai.com/logo.png><link rel=icon type=image/png sizes=16x16 href=https://go.face2ai.com/logo.png><link rel=icon type=image/png sizes=32x32 href=https://go.face2ai.com/logo.png><link rel=apple-touch-icon href=https://go.face2ai.com/logo.png><link rel=mask-icon href=https://go.face2ai.com/logo.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-105335860-3","auto"),ga("send","pageview"))</script><meta property="og:title" content="30天自制操作系统"><meta property="og:description" content="30天自制操作系统1 Mac下工具的使用 现在来介绍官网上下的工具怎么用首先是官网地址，书上有个注释上有:hrb.osask.jp 翻译成中文大概是这个样子滴。
上面有两个文件可以下载，一个是工具，一个是工具的源代码，很好的学习资料
下面把工具复制出来
看到很多可执行文件。。感觉好舒服。。
然后把我们随便一个project复制到z_tools的同级目录下
project的内容可以修改，因为批处理可以下岗了：
然后可能是难度最大的部分出现了:修改makefile
如果没用过makefile可以先找点资料看看。很简单的语法，很强大的功能： 修改完成后是：
 TOOLPATH = ../z_tools/ INCPATH = ../z_tools/haribote/ ################################################### MAKE = make NASK = $(TOOLPATH)nask CC1 = $(TOOLPATH)gocc1 -I$(INCPATH) -Os -Wall -quiet GAS2NASK = $(TOOLPATH)gas2nask -a OBJ2BIM = $(TOOLPATH)obj2bim BIM2HRB = $(TOOLPATH)bim2hrb RULEFILE = $(TOOLPATH)haribote/haribote.rul EDIMG = $(TOOLPATH)edimg IMGTOL = $(TOOLPATH)imgtol.com COPY = cp DEL = rm ################################################### ## ÉfÉtÉHÉãÉgìÆçÏ default : $(MAKE) img ## ÉtÉ@ÉCÉãê∂ê¨ãKë• ipl10.bin : ipl10.nas Makefile $(NASK) ipl10."><meta property="og:type" content="article"><meta property="og:url" content="https://go.face2ai.com/%E7%BC%96%E7%A8%8B/30-days/30_days_system/"><meta property="article:section" content="编程"><meta property="article:published_time" content="2013-12-13T14:42:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="30天自制操作系统"><meta name=twitter:description content="30天自制操作系统1 Mac下工具的使用 现在来介绍官网上下的工具怎么用首先是官网地址，书上有个注释上有:hrb.osask.jp 翻译成中文大概是这个样子滴。
上面有两个文件可以下载，一个是工具，一个是工具的源代码，很好的学习资料
下面把工具复制出来
看到很多可执行文件。。感觉好舒服。。
然后把我们随便一个project复制到z_tools的同级目录下
project的内容可以修改，因为批处理可以下岗了：
然后可能是难度最大的部分出现了:修改makefile
如果没用过makefile可以先找点资料看看。很简单的语法，很强大的功能： 修改完成后是：
 TOOLPATH = ../z_tools/ INCPATH = ../z_tools/haribote/ ################################################### MAKE = make NASK = $(TOOLPATH)nask CC1 = $(TOOLPATH)gocc1 -I$(INCPATH) -Os -Wall -quiet GAS2NASK = $(TOOLPATH)gas2nask -a OBJ2BIM = $(TOOLPATH)obj2bim BIM2HRB = $(TOOLPATH)bim2hrb RULEFILE = $(TOOLPATH)haribote/haribote.rul EDIMG = $(TOOLPATH)edimg IMGTOL = $(TOOLPATH)imgtol.com COPY = cp DEL = rm ################################################### ## ÉfÉtÉHÉãÉgìÆçÏ default : $(MAKE) img ## ÉtÉ@ÉCÉãê∂ê¨ãKë• ipl10.bin : ipl10.nas Makefile $(NASK) ipl10."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"30天自制操作系统","item":"https://go.face2ai.com/%E7%BC%96%E7%A8%8B/30-days/30_days_system/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"30天自制操作系统","name":"30天自制操作系统","description":"30天自制操作系统1 Mac下工具的使用 现在来介绍官网上下的工具怎么用首先是官网地址，书上有个注释上有:hrb.osask.jp 翻译成中文大概是这个样子滴。\n上面有两个文件可以下载，一个是工具，一个是工具的源代码，很好的学习资料\n下面把工具复制出来\n看到很多可执行文件。。感觉好舒服。。\n然后把我们随便一个project复制到z_tools的同级目录下\nproject的内容可以修改，因为批处理可以下岗了：\n然后可能是难度最大的部分出现了:修改makefile\n如果没用过makefile可以先找点资料看看。很简单的语法，很强大的功能： 修改完成后是：\n TOOLPATH = ../z_tools/ INCPATH = ../z_tools/haribote/ ################################################### MAKE = make NASK = $(TOOLPATH)nask CC1 = $(TOOLPATH)gocc1 -I$(INCPATH) -Os -Wall -quiet GAS2NASK = $(TOOLPATH)gas2nask -a OBJ2BIM = $(TOOLPATH)obj2bim BIM2HRB = $(TOOLPATH)bim2hrb RULEFILE = $(TOOLPATH)haribote/haribote.rul EDIMG = $(TOOLPATH)edimg IMGTOL = $(TOOLPATH)imgtol.com COPY = cp DEL = rm ################################################### ## ÉfÉtÉHÉãÉgìÆçÏ default : $(MAKE) img ## ÉtÉ@ÉCÉãê∂ê¨ãKë• ipl10.bin : ipl10.nas Makefile $(NASK) ipl10.","keywords":[],"articleBody":"30天自制操作系统1 Mac下工具的使用 现在来介绍官网上下的工具怎么用首先是官网地址，书上有个注释上有:hrb.osask.jp 翻译成中文大概是这个样子滴。\n上面有两个文件可以下载，一个是工具，一个是工具的源代码，很好的学习资料\n下面把工具复制出来\n看到很多可执行文件。。感觉好舒服。。\n然后把我们随便一个project复制到z_tools的同级目录下\nproject的内容可以修改，因为批处理可以下岗了：\n然后可能是难度最大的部分出现了:修改makefile\n如果没用过makefile可以先找点资料看看。很简单的语法，很强大的功能： 修改完成后是：\n TOOLPATH = ../z_tools/ INCPATH = ../z_tools/haribote/ ################################################### MAKE = make NASK = $(TOOLPATH)nask CC1 = $(TOOLPATH)gocc1 -I$(INCPATH) -Os -Wall -quiet GAS2NASK = $(TOOLPATH)gas2nask -a OBJ2BIM = $(TOOLPATH)obj2bim BIM2HRB = $(TOOLPATH)bim2hrb RULEFILE = $(TOOLPATH)haribote/haribote.rul EDIMG = $(TOOLPATH)edimg IMGTOL = $(TOOLPATH)imgtol.com COPY = cp DEL = rm ################################################### ## ÉfÉtÉHÉãÉgìÆçÏ default : $(MAKE) img ## ÉtÉ@ÉCÉãê∂ê¨ãKë• ipl10.bin : ipl10.nas Makefile $(NASK) ipl10.nas ipl10.bin ipl10.lst asmhead.bin : asmhead.nas Makefile $(NASK) asmhead.nas asmhead.bin asmhead.lst bootpack.gas : bootpack.c Makefile $(CC1) -o bootpack.gas bootpack.c bootpack.nas : bootpack.gas Makefile $(GAS2NASK) bootpack.gas bootpack.nas bootpack.obj : bootpack.nas Makefile $(NASK) bootpack.nas bootpack.obj bootpack.lst bootpack.bim : bootpack.obj Makefile $(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \\ bootpack.obj ## 3MB+64KB=3136KB bootpack.hrb : bootpack.bim Makefile $(BIM2HRB) bootpack.bim bootpack.hrb 0 ################################################## haribote.sys : asmhead.bin bootpack.hrb Makefile cat asmhead.bin bootpack.hrbharibote.sys ################################################### haribote.img : ipl10.bin haribote.sys Makefile $(EDIMG) imgin:../z_tools/fdimg0at.tek \\ wbinimg src:ipl10.bin len:512 from:0 to:0 \\ copy from:haribote.sys to:@: \\ imgout:haribote.img ## ÉRÉ}ÉìÉh img : $(MAKE) haribote.img ################################################# run : $(MAKE) img qemu -fda haribote.img ################################################### clean : -$(DEL) *.bin -$(DEL) *.lst -$(DEL) *.gas -$(DEL) *.obj -$(DEL) bootpack.nas -$(DEL) bootpack.map -$(DEL) bootpack.bim -$(DEL) bootpack.hrb -$(DEL) haribote.sys src_only : $(MAKE) clean -$(DEL) haribote.img 乱码是原来的日语。。华丽的忽视掉，一排#之间的就是修改过的地方， 然后就是make run了。。 结果如下：\nMac环境搭建 (2013-12-13 14:20:00) 弄了三天了，终于弄好了，先说结果，就是作者在网站上放了os x的工具（hrb.osask.jp，也有linux下的工具，可以自己去下载），也就是说我白忙活了三天。。。\n再说一下这几天都干啥了，主要是想把c语言和nasm汇编连在一起。这个很多人都做过，但在网上现有的资料很少有在os X上做的的，也或者做了大家都没人说。。。。先贴代码：\nextern void swap(int *,int *); void main(){ int a=1; int b=2; swap(\u0026a,\u0026b); while(a==2) ; } 这是c代码，调用swap交换两个值，为了不调用标准库，我没写显示函数，而是用了一个死循环代替，如果程序停住了，说明运行成功，再贴下汇编，这是我第一次写汇编哦。。啦啦啦啦啦\nGLOBAL _swap [section .text] _swap: mov EDX,[ESP+4] mov EAX,[ESP+8] mov EBX,[EDX] mov ECX,[EAX] mov [EDX],ECX mov [EAX],EBX ret 代码很简单，但是和书上格式有些不同，作者说的他用的是nask是他自己改版的nasm所以有些关键字用不了。。。\n然后是编译成obj文件，这个很纠结，一开始不会用gcc编译出32位obj后来发现要加：\n\\-m32 就可以了。\n编译过程如下图：\n整个编译连接过程，最后光标停止，说明函数执行成功，如果nasm中写了什么中断或者什么其他系统不允许的可能会有总线错误（bus error）或者段错误（详情可以去看《c专家编程》，有相关说明）。 值得注意的是nasm -f 的参数：\nvalid output formats for -f are (\\`\\*' denotes default): \\* bin flat-form binary files (e.g. DOS .COM, .SYS) aout Linux a.out object files aoutb NetBSD/FreeBSD a.out object files coff COFF (i386) object files (e.g. DJGPP for DOS) elf ELF32 (i386) object files (e.g. Linux) as86 Linux as86 (bin86 version 0.3) object files obj MS-DOS 16-bit/32-bit OMF object files win32 Microsoft Win32 (i386) object files rdf Relocatable Dynamic Object File Format v2.0 ieee IEEE-695 (LADsoft variant) object file format macho NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X object files 这个参数纠结了好久，最后还是看帮助搞定的，因为linux下都是elf，但是os x用elf参数最后ld会报错，说找不到xxx函数定义。。 ld的相关问题：\n1：ld: symbol(s) not found for inferred architecture i386 2：ld: symbol(s) not found for inferred architecture x86\\_64 3：ld: warning: ignoring file xxxx.o, file was built for unsupported file format 1，2和3的问题原因都是-f参数选的不对，或者gcc编译出来的是64位obj，nasm只能编译出来32或者16位目标代码。\n如果和系统可运行程序不对应，ld不会给你链接的\n最后是objcopy，这个是GNU 的binutils的工具包的一部分。作用是操作二进制文件，可以任意改格式，具体参考说明，吧之前链接好的用objcopy生成纯二进制文件后，和作者的比较发现，不一样，运行时qemu卡死，得到结论就是这两天又白忙活了。还好算是找到了工具，也有源代码，值得好好学习。\nMac环境下的工具介绍 (2013-12-09 20:20:00) 这几天一直在搞这个破环境，尝试各种做法，网上各种垃圾信息，浪费了很多时间，说的基本都是废话，不过还是找到了一些，赶紧写下来，不然这个过几天又忘了\n首先是环境，我用的是Max os Maverick 64，就是10.9，硬件（有点低0.0，对于小菜的我已经完全够用啦）：\n10.9刚发布，新出来的东西总问题一大堆，然后解决办法没几个。但是还是能用了，编译器NASM（xcode中command line tools带的那个）xcode真的很大，但是不可否认，安装比vs2010快多了。基本指令是dd指令，和cat指令，这两个和linux下差不多. 首先建立一个.img的镜像文件：\ndd if=xxxxx of=xxxx.img count=20000 注意，if后面的参数是个文件夹，用空的，of参数是输出的img文件 count 是大小，自己十几次就知道了, 然后编写ipl。 注意，后缀用.s而不用nas哦，因为.s的文件vi编辑器会自动语法高亮 然后要说一下ipl中的一句话\nRESB0x7fde-$ 这句话汇编通不过：提示这一行有非法操作符。。我也不知道咋回事。。。。。 改成：\n就可以顺利的汇编成bin文件了接着，用CAT指令把bin塞到img中\ncat ill.bin  xxxx.img 然后用qemu执行以下\nqemu -fda xxxx.img 结果如图： 用到的工具软件我会上传，安装比较简单，都是dmg的，双击就好。后天继续把c语言弄进来\n保护模式 (2013-11-27 16:55:00) 软盘？不需要！ 昨天一天看了5天内容，把觉得有些可能不好理解的写下来，内容不分先后，感觉作者写的通俗易懂，而且代码以及工具在xp下运行流畅，根本不需要软盘，直接在工具提供的虚拟机上跑就可以，下面来描述下昨天的学习心得和问题。\n首先是内存，对内存的管理是至关重要的，所以我们应该先了解一下内存的具体分布:\n这个图是我找的，如果有打错的地方或者有什么变动，请留言，不胜感激。 这就是内存的分配，对于小菜理解有些困难。接下来可能就是从加电到系统启动的过程的理解了. 实模式下（为保护模式做准备），启动并加载过程如下图：\n至于为什么到0x07c00，原因是“两头约定”（就是设计BIOS的大伯们和设计操作系统的大叔们商量好，把启动程序放那，一后大家开发都方便）。 里面用到的汇编命令，可以去看一些汇编的书，王爽老师的那本书不错，还有《深入理解操作系统》里面的知识和这里用到的也很合拍，都是好书，可以看看。 没有写完，下一篇继续写前五天的。\nIPL，BIOS (2013-11-27 18:20:00) IPL 其实还是前五天的，现在继续说，第三天，p49页下面部分说“0x8000到0x81ff是启动区”而0x7c00到0x7dff也是启动区，这个地方困扰了我好久，不过今天好像看到类似的说法了:在linux中启动区启动后会将启动区复制到0x90000的地方，原因也没说，知识含糊的说为后面的栈操作做准备，其实无论怎么放，这只是表明，IPL功能已经工作了，成功的实现了转移，我们可以自己来控制电脑了。 在IPL的实现过程中，我发现BIOS中断的威力相当大，就像平时我们用库函数一样，各种寄存器就是这些函数的参数，可以实现硬件的各种操作，准备明天起早找点BIOS中断的资料贴一下，如果能熟练运用会有很牛的感觉，已经接近硬件了，很兴奋。。。汇编是一把利器。\n汇编与C语言 (2013-11-27 19:07:00) 汇编语言函数用c语言调用 其实我们可以把这些在完成操作系统编写时写的函数称为库函数（注意：不是标准库函数），但是c在调用库函数（普通函数），压栈的顺序是从右向左的，这个是肯定，所以，参数出栈的时候先出来的是后面的参数，明白了这个问题，就很好理解io_out()函数参数的出栈和参数的使用了，还有函数如果有返回值，保存在eax（32位返回值），64位返回值保存在 eax 和edx中，edx保存高32位，eax保存低32位。\n知道了这些，参数和返回值就已经搞定了，剩下的就是定义和具体代码的实现了，什么利用中断啊，MOV给你MOV给我啊的什么就可以自由发挥了。\n看起来已经很酷了。 函数定义，搜了一下，发现定义都不同，但都是写global声明下函数名（名字前面加下划线），然后以函数名为标号写下函数体，返回用ret（但有些函数好像不能用RET返回。。具体以后再说）。\n还有就是函数指针，由于博主以前研究了好长时间指针，虽然不能说特别明白，但是看这个书上的指针还是没什么障碍，像什么2【p】这种访问方式，以前也都见过，如果有人这里有疑问推荐几本书：《c专家编程》《c陷阱与缺陷》《c和指针》都有详细描述，自己写个程序试试就行了，这里不再赘述。\nGDT和IDT (2013-11-27 20:12:00) GDT和IDT 全局描述表（GDT ，Global Descriptor Table）：首先看到全局说明这货很重要，应该是掌握了一些，其次这个表是个数组，所以，这是一个重要的数据结构。\nGDT数组中装的是段描述符【段地址，段的最大长度，访问权限】。因为这个描述符太大了，没有这么大的寄存器（64位），所以就把这个描述符放在内存里，成为了重要的GDT，intel的大叔们设计了一个寄存器GDTR（LGDT为装入此寄存器指令）用来存放GDT的入口地址，因为GDT可以设计到内存的任何位置，而GDTR可以帮助快速定位，这样段寄存器的13位就能索引到GDT了。GDT是保护模式必备的数据结构。能够很好的划分内存，控制程序的内存方位（不然会出大问题）。\n中断描述符表（IDT Interrupt Descriptor Table）：之前已经见识过中断的强大了，这个描述符表是管理中断的，很明显是高手中的高手，其实他是一个8字节的描述符数组，也是一种重要的数据结构。IDT只要保存256个描述符就够了，因为最多也不会有超过256种中断，甚至IDT可以少于256，只要够用就行。同样，IDT可以放在内存的各个角落，只要你愿意，但是一定要是线性的，不然就找不到了（这是个数组，当然线性了），IDT也有专门的寄存器存放入口地址，叫IDTR，这个寄存器中含有IDT表32位的基地址（高32位）和16位的长度（限长）值（低16位）。IDT表基地址应该对齐在8字节边界上以提高处理器的访问效率。LIDT和SIDT指令分别用于加载和保存IDTR寄存器的内容。LIDT指令用于把内存中的限长值和基地址操作数加载到IDTR寄存器中。该指令仅能由当前特权级CPL是0的代码执行，通常被用于创建IDT时的操作系统初始化代码中。如果有越界访问IDT的现象会触发一个保护性异常。\n中断向量表：实模式下的前1K个字节为中断向量表，每项有四字节（2字节的段地址，2字节的偏移地址，来定位实模式下的1M空间），用来指向中断处理程序的位置，但是在保护模式下，4字节不够用，需要8字节，所以改名IDT，而且位置也不局限于开始的0x00000处，使用全新的方式完成中断处理。\nIDT中的每一项叫“门”（门描述符），很明显是传送门。。哈哈。。\n中断处理 (2013-11-28 16:20:00) 中断处理 我感觉中断处理应该是系统底层设计的关键，因为这是在控制硬件，和给c提供接口，如果接口搞不好，一路兵败如山倒\n分割编译其实就是c语言初等知识，就是别写的太乱，每个文件放不同的东西，头文件加以说明和声明，以及一些宏定义或者什么的，可以去查查相关c语言的资料。 今天让我纠结了一下午的东西在p113，也就是调整栈内容，用以组合出GDTR的48位数据那个地方，很纠结，现在来说明一下：\n首先是c语言函数调用时参数传递问题，先从右边开始压栈，直到所有参数完成，但是在CALL的时候还要对CS：EIP进行压栈，这是个啥东西我也不清楚，所以我们可以看到取参数都从【ESP+4】开始取的，取参数的位置是【ESP+4】,【ESP+5】….取多少位就一直加加加。还有就是超过8位以上的数据在内存中存放的规律，如果是8位以下的一个内存单元就可以了，但要是16位32位呢，这就涉及到了大端机（Big-endian）和小端机（Little-endian）的区别了，首先我们以0x12345678为例，32的数据存储：\n就是高地址存高位还是低位的区别，不是很好理解，慢慢熟悉就好了，具体机器是大端还是小端写个c程序就行了，用一个联合来测试一下，具体自己发挥，《c语言深度解剖》有相关描述，好多书都提到过。 下面是113页困扰我很久的问题的具体解析：\n这就是那个GDT初始化函数调用时栈的内容，首先很纠结的就是栈底在高地址，栈是向下生长的，所以，看着很别扭，还有就是esp（栈顶指针）不是指向第一个参数的，剩下的问题就很好说了，如果要从内存0x02abf8读取两个字节，那么跟着0x2abf8后面的f9会被连带访问而不是f7。。。。。 接下来说PIC，这是个硬件，如果有点电路知识就应该没啥障碍了，是一个存储设备，cpu可以从他取数据，具体怎么去要看这个片子功能的设计和相关信号的传递方法，没有什么需要解释的，设计完全是为了便于开发。 中断程序的制作应该是核心问题，以及缓冲区的使用，明天再说。感谢收看，\n中断 (2013-11-29 13:23:00) 中断处理程序 今天看的还是比较顺利，很快一天的就看完了，总结一下今天的主要知识。\n首先是中断处理程序，中断处理程序尽量高效，短小精悍，所以像显示啊什么的操作尽量不再中断处理程序中出现，因为一旦进入中断处理程序，其他中断将会被屏蔽，因为如果不屏蔽就会出现乱套的现象，一个中断还没完另一个已经来了，你说你干不干，干哪个，所以，尽量减少中断处理时间，这样就可以减小中断同时发生而后发生的没办法处理的现象，所以，缓冲区出现了用武之地。\n之前一直不知道缓冲区是干嘛的，今天终于见到其真正的用途了，就是保存中断信息，然后慢慢处理，之后讲到FIFO缓冲区（讲的不严谨点就是队列），队列的大小随意定义，为了减少数据移动，使用了循环队列，高效，但结构里面有一个len用来判断对是否满，可以用头指针和尾指针的位置关系来判断，但没有多大效率上和空间上的区别，所以应该都可以，这里的队列采用数组而不是链表，数组在空间上连续，所以读的速度更快。效率才是硬道理！\n发现了对中断的处理和处理时对下一个中断的到来以及处理安排上是很重要的，需要我们严加设计的，应该也是系统设计的重要部分，还有书中出现的各种编号（像不同端口的地址什么的），不知道具体去哪找，不同的cpu不知道有没有什么区别，这是不是就Intel那个好几千页的手册所要说明的。\n还有就是鼠标和键盘的电路是一个芯片组上的。\n这几天基本都是用c语言设计，感觉只用汇编写了那些最基本的函数，如果系统想要更强大是不是应该多用汇编写点更多的函数以供调用。\n鼠标 (2013-11-30 15:44:00) 啊哈，鼠标 今天看的有点纠结，因为竟然看困了，很少有这种情况，主要是有好多东西作者并没有做深入介绍，只是说这样是对的，至于为啥这样以后再说，这让我感觉很不爽。具体来说说。\n首先，先解决了鼠标运动的问题，我感觉这个不是什么大问题，只是读取数据那需要点技巧，就是验证数据的有效性，以前用单片机发送串口数据时也用到过类似的做法，作者提出的是检查第一个字的低八位以及高两位，如果高两位是0，而低八位是8，那么数据没问题，但并不一定绝对没问题，比如发送的数据为 0x08 0x00 0x11下一组为0x08 0x08 0x01时也就是队列里面是0x08 0x00 0x11 0x08 0x08 0x01时如果红色字体丢失任意一组数据，其结果和下一组结果都是错误的，但发生的概率很小，我们也没必要要求硬件每发送一个数据都要加上校验位，那样冗余太大，也浪费资源，而且估计鼠标也不会总坏。\n个人来讲，我不想将桌面作为系统开发的前期所应该做的（等我自己写的时候不会这么弄），一个黑漆漆的命令行而具有更强大的功能，我觉得更好，而且将桌面和系统剥离开，也就是linux那样，感觉更加自由。哈哈，这都是自己的想法，没有任何科学根据。接下来就到了让我纠结的地方了，就是作者解释了之前没解释的汇编代码：\n ; haribote-os boot asm ; TAB=4 BOTPAK\tEQU\t0x00280000\t; c语言编写部分的入口位置 DSKCAC\tEQU\t0x00100000\t; 启动区将要被复制到的地方 DSKCAC0\tEQU\t0x00008000\t; dskcaco启动区存储地址，其实里面没啥，知识为了预留，这也是之前纠结的地方 ; BOOT_INFO関係 CYLS\tEQU\t0x0ff0\t; LEDS\tEQU\t0x0ff1 VMODE\tEQU\t0x0ff2\t; SCRNX\tEQU\t0x0ff4\t; SCRNY\tEQU\t0x0ff6\t; VRAM\tEQU\t0x0ff8\t; ORG\t0xc200\t; ; 显示设置，中断号10H具体中断用法参照google MOV\tAL,0x13\t; MOV\tAH,0x00 INT\t0x10 MOV\tBYTE [VMODE],8\t; MOV\tWORD [SCRNX],320 MOV\tWORD [SCRNY],200 MOV\tDWORD [VRAM],0x000a0000 ; 设置键盘中断，中断号16H，自行百度 MOV\tAH,0x02 INT\t0x16 ; keyboard BIOS MOV\t[LEDS],AL ; ;\tPIC必须在CLI之前设置好 ;\t有些机型不能连续使用OUT指令，中间要停一下 ;\tPIC初始化 ; CLI指令后CPU屏蔽所有中断 MOV\tAL,0xff OUT\t0x21,AL NOP\t; OUT\t0xa1,AL CLI\t; ; 开启A20设置，这里的具体原理见下文。。 CALL\twaitkbdout MOV\tAL,0xd1 OUT\t0x64,AL CALL\twaitkbdout MOV\tAL,0xdf\t; enable A20 OUT\t0x60,AL CALL\twaitkbdout ; 这就是个简单设置并等待反馈的过程，书上说可以同时读取鼠标和键盘。。。我没看出来 [INSTRSET \"i486p\"]\t; 指令集，不知道酷睿2应该咋表示0.0 LGDT\t[GDTR0]\t; 设定GDT MOV\tEAX,CR0 AND\tEAX,0x7fffffff\t; OR\tEAX,0x00000001\t; 将EAX设置成二进制 1xxx xxxx xxxx xxxx xxxx xxxx xxxx xxx1的形式 MOV\tCR0,EAX ；CR0很高端的寄存器，只有操作系统可以使用 JMP\tpipelineflush pipelineflush: MOV\tAX,1*8\t; 1*8不知道是啥意思。。。。。 MOV\tDS,AX MOV\tES,AX MOV\tFS,AX MOV\tGS,AX MOV\tSS,AX ; bootpack MOV\tESI,bootpack\t; 复制的原始地址 MOV\tEDI,BOTPAK\t; 复制的目标地址 MOV\tECX,512*1024/4 ；DWORD是单位 CALL\tmemcpy MOV\tESI,0x7c00\t; 同上 MOV\tEDI,DSKCAC\t; 同上 MOV\tECX,512/4 CALL\tmemcpy ; 残り全部 MOV\tESI,DSKCAC0+512\t; MOV\tEDI,DSKCAC+512\t; MOV\tECX,0 MOV\tCL,BYTE [CYLS] IMUL\tECX,512*18*2/4\t; SUB\tECX,512/4\t; 真心不知道这步干啥用 CALL\tmemcpy ; bootpack开启 MOV\tEBX,BOTPAK MOV\tECX,[EBX+16] ADD\tECX,3\t; ECX += 3; SHR\tECX,2\t; ECX /= 4; JZ\tskip\t; 如果哦ECX2==0，则跳转 MOV\tESI,[EBX+20]\t; 还是复制。。 ADD\tESI,EBX MOV\tEDI,[EBX+12]\t; CALL\tmemcpy skip: MOV\tESP,[EBX+12]\t; 不懂在干啥。。。 JMP\tDWORD 2*8:0x0000001b waitkbdout: IN\tAL,0x64 AND\tAL,0x02 JNZ\twaitkbdout\t; 读入0x64的响应和0x02做与运算，非零则跳转 RET memcpy: MOV\tEAX,[ESI] ADD\tESI,4 MOV\t[EDI],EAX ADD\tEDI,4 SUB\tECX,1 JNZ\tmemcpy\t; 复制过程比较简单 RET ALIGNB\t16 GDT0: RESB\t8\t; DW\t0xffff,0x0000,0x9200,0x00cf\t; DW\t0xffff,0x0000,0x9a28,0x0047\t; 不知道在干嘛。。写了这么多奇怪的地址 DW\t0 GDTR0: DW\t8*3-1 ；依旧不知道8*3哈意思 DD\tGDT0 ALIGNB\t16 bootpack: 好吧，我的理解就只能到上面这个地步，不知道再继续往下看还能多领悟点不了。\n为什么是向键盘发送指令来控制A20GATE呢？百度到的原因是为了控制是否使用超过1M以上的内存，并和16位兼容，IBM的老爷爷们使用键盘控制器剩下的一根信号线来控制A20，A20不是控制是否进入保护模式。\n原始16位处理器访问最高地址为0xFFFF：0xFFFF=0xFFFF0+0xFFFF=0x10EFFEF,很明显多于1M对于多出来的0xEFFEF的访问就需要另外的地址线。但是系统的做法是当程序员访问多于1M的地址时，CPU将地址按1M取模。。这样就不会超过1M了，这种技术被称为wrap-around\n到了80286出现了一些问题，当程序员试图访问1M到0x10EFFEF时系统并没有循环回去而是直接访问，这导致了和之前产品不兼容，于是为了兼容，设计了第21根信号线就是上面提到的键盘控制器多余的这根，称为A20来控制是否访问1M以后的地址，当设置为打开时可以访问到多于1M的地址，关闭时则只能循环回0按8086的方式访问。\n以上都是实模式下的，在保护模式下，CPU访问的内存增加，如果这个20位的控制线不被打开，那我们的第20号位地址将被视为无效，内存将会被切割成小碎片，系统将只能访问以基数兆的内存。。所以必须要打开A20才能完整访问。至于A20和键盘的关系。就是没啥关系，只不过用一个控制器。 一下内容来自互联网（没有验证准确性）：\n 多数PC都使用键盘控制器（8042芯片）来处理A20Gate。 从理论上讲，打开A20Gate的方法是通过设置8042芯片输出端口（64h）的2nd-bit，但事实上，当你向8042芯片输出端口进行写操作的时候，在键盘缓冲区中，或许还有别的数据尚未处理，因此你必须首先处理这些数据。 流程如下：  禁止中断；  等待，直到8042 Inputbuffer为空为止； 发送禁止键盘操作命令到8042Input buffer； 等待，直到8042 Inputbuffer为空为止； 发送读取8042 OutputPort命令； 等待，直到8042 Outputbuffer有数据为止； 读取8042 Outputbuffer，并保存得到的字节； 等待，直到8042 Inputbuffer为空为止； 发送Write 8042Output Port命令到8042 Input buffer；  等待，直到8042 Inputbuffer为空为止；  将从8042 OutputPort得到的字节的第2位置1（OR 2），然后写入8042 Input buffer；  等待，直到8042 Inputbuffer为空为止；  发送允许键盘操作命令到8042Input buffer；  打开中断。   内存管理 (2013-12-01 13:47:00) 内存管理 对于一个系统来说，资源是最重要的，管理资源应该说就像计划你口袋里面的钱怎么花一样（不太准确。。但是重要性是相似的）。\n首先是检查内存大小，BIOS应该是提供内存大小检查功能的，但是不同的BIOS查找内存大小的方式不同，所以我们应该以一种更为通用的方法进行，以获得更好的系统兼容性，而且现在的CPU都配有各种缓存，一级，二级，三级。。。先要禁止高速缓存，才能确保访问的变量全部在内存中，所以，先禁用缓存（设置CR0的某个标志位为指定值，本书还检查了一下机器是否有高速缓存，这个现在基本不用检查了，我还真就没见过386长什么样）。禁用掉高速缓存我们就要对内存挨个访问了，看看到底有没有这个位置，对0xaa55aa55的反转和比较再反转，我感觉没有什么具体意义，你可以改成任意的数字，如果访问的内存地址不存在，则返回记录到的最大的位置值，后面的程序是优化次功能程序，如果只为了检查内存的大小，完全可不用一个一个来，而是十个十个来或者一万个一万个来，只检查最后的几位就行，这个的速度会按照相应的倍数提升而准确度也会随之下降。如果要做内存健康检查就要一个一个来了。书中还有一个涉及到编译器的优化问题，这个会在后续的博客中详细介绍。\n接下来，检查完内存就要对内存分配进行管理了，这个应该是个很困难的问题，书中的方法有两种。\n第一种：首先设置内存分配的最小单位，书中为4KB，把所有能用的字节都统计出来划分成4KB一段的好多个内存块，然后用一个字符数组来记录那些很忙，那些很闲，然后分配给需要的程序，这样的代价是每4K就需要8BIT的空间来标记这块的可用性（8/（4×1024）=1/512）所以代价是恒定的，不论多大内存N GB，都需要（N/512GB的内存来记录），这样的好处也是第二种方法的缺点就是不用做拼接，碎片问题容易解决。据说内存碎片是个很可怕的问题，尤其是对于长时间运行的服务器。\n第二种：用一个数据结构记录所有内存的使用情况，这个数据结构内包含一个可用空间大小的记录，还有就是N个用于记录内存起始地址和可用大小的子结构数组了。\nstruct FREEINFO { unsigned int addr, size;//起始地址，和大小  }; struct MEMMAN { int frees, maxfrees, lostsize, losts;\t//这是内存的一些记录，包括可用空间，最大可用空间，释放失败大小，释放失败的次数  struct FREEINFO free[MEMMAN_FREES]; //具体的信息。。  }; 第二种方法速度快，占用空间小，但是分配时产生的细小的内存空间没有被使用，和回收内存时的合并操作都相当麻烦。。所以有利有弊，当内存碎片过多，而系统回收算法不够强壮时有可能是灾难性的。\n至于设计系统时用什么样的内存管理方法，目前还没想好，总之，这是个很关键的问题。会找一些资料，在后续的博文中陆续推出，欢迎收看\n内存管理和叠加处理 (2013-12-02 13:42:00) 内存管理和叠加处理 今天的代码比较多，对于写过程序的人来说应该还是比较容易看懂的。 首先说的内存管理，昨天说道把很多内存分成0x1000字节大小的块，然后分配给程序使用，但是不一定所有的程序用到的都是0x1000的整数倍字节，所以就要设计一个取整的方法，就有了书中提到的聪明做法（size+0xfff）\u00260xfffff000;这个做法或者称为算法的正确性证明很简单，带两个数试一下就知道玄机了，就是把一个12位非零二进制数向前进位，而零不进位，最后把后3位归零。我们还可以把大于x的任何数进位，小于等于x的舍去（size+0x1000-x-1）\u00260xfffff000；哈哈，应该是对的，我也没有证明。不过x=0是和原式一样的。举一反三山寨之本。\n接着就到了我很疑惑的地方了。叠加处理，但是！！！注意！！！作者开始给结构体显示的分配内存了，就是图层的控制结构体，我不明白，之前写的那些结构体也没分配内存，为啥突然从这开始分配了，而作者根本没提，难道是因为昨天才写的内存管理，今天就开始用了？那之前的程序怎么办呢。我一会儿还是好好研究一下。\n感觉要设计系统，就应该对这个系统的宏观结构应该完全清楚，骨架清晰，内容就可以随意发挥了。现在是骨架还没搞清楚，所以博猪没有一开始就写自己山寨版，而是想把书看完，然后找点操作系统相关的书再看看然后再做个试验品出来玩玩。。哈哈。。不知道思路正确不正确。。\n至于这个叠加处理，其基本目的是控制多个图层，设计相应的数据结构。而刷新那里作者反复的实验，但其本质就是减少冗余计算，就是说有些计算能剩就不做，就像一个简单的图像卷积（好吧，博猪以前做过一段时间图像处理，听不懂的可以完全忽略。。）如果按照算法做，时间复杂度是 $O(xysizesize)$（x，y是图像的大小 $xy$ 个像素，size是卷积核宽度），但经过优化可以做到只要 $O(x*y)$ ，而方法就是要用到前一步的计算结果，减少冗余的计算量（好吧，这是博猪第一次面试的面试题，很幸运。公司没要我0.0）。好，叠加的优化原理是哪个地方改变了，就刷新改变的区域的像素。至于实现细节，书中的代码有详细介绍，关键是确定叠加区域，然后重绘叠加区域。。。 明天继续努力。\n定时器 (2013-12-03 14:06:00) 闪烁和定时器 今天的主要内容是屏幕刷时的闪烁问题，和定时器的小部分内容。\n首先说明定时器应该是系统重要部分，所以明天会好好记录一下计时器的心得。\n关于屏幕刷新时闪烁，这个之前也遇到过（之前做单片机数据绘图时，因为单位时间数据量很大，一直刷新画面就会导致波形图闪烁，而解决这个问题的方法是使用双缓存技术），而这次不同的是如果系统桌面都闪烁，就没人会使用我们的系统了。。所以问题很严重，需要马上解决，作者的解决方法是改变刷新的范围和层数，减少无谓的刷新。其实作者从开始所提出的桌面显示的完整体系就是一种最简单的设计（作者想带着我们一步一步走向高端，但如果看完全书后再去写的话就不需要走弯路了），我们设计时完全可以自己发挥，设计出更高效更华丽的桌面环境，作者最后提到的在内存中开辟map区域其实就是一种高效的方法，而这个方法可以在一开始显示的时候就设计进去，所以，桌面显示并不应该成为我们学习的重点（在系统体系完成后再详细设计规划）。\n相反，计时器才是我们应该好好研究的，这是系统的根本之一。\n计时器 (2013-12-05 19:00:00) 计时器 昨天一直在搭建环境，想在mac下实现书上制作镜像和编译连接相关文件的功能，无奈，弄了一天还是不太好用，看到另外一个微博上的童鞋用Linux完成了相关操作，想试一下，但os x上没有objcopy等命令，而且gcc好像也是改版的，而且现在被我折腾的连命令行下使用command line tools 都有问题，所以，我还是回来把笔记补上。一会儿再去弄，争取放假之前能把环境搞定，这样寒假就可以专心研制自己的系统了，而不用把时间花到细枝末节上。\n昨天的内容讲的是计时器，我一开始没觉得定时器有啥功能，无非是弄个钟表出来，后来我看到了超时（timeout）恍然觉得这个东西很主要，作者并没有直接说去定时器在以后的实现中有什么作用，但是一直对中断处理程序进行优化可以看出，这个东西以后要被不停地使用，而且作者提出定时器后，马上有多弄了几个，而且最多能实现500个定时器，第十二天的主要工作就是优化处理速度，因为中断处理时所有的中断信号都被屏蔽了，所以必须快速的处理，恢复中断响应。\n下面的图是作者最开始的设计：\n其中条状的是定时器的执行时间，横坐标是时间，纵坐标是各定时器，不论有多少个定时器，都要循环500次（也就是最多个的情况），所以这对要求效率的工作并不是个好主意，于是开始优化。\n首先可以将定时器排队，就像我们有两场球赛在不同的频道，一个十分钟后在c1频道，一个二十分钟后在c2频道，我们只要盯着那个十分钟后开始的c1频道就可以了，你可以每两分钟过来看一下，如果c1开始了，我们才会去关注c2是否开始（寝室有一哥们能同时看三场球。。。。）也就是说c1不发生，理论上来说c2绝不会发生，所以就优化出了下图：\n上图横轴是时间，没有纵轴，每个小格子就是不同的定时器之间的间隔，每个定时器都是从头开始到对应的线，也就是把所有定时器从小到大排列起来，然后弄到一根轴上，这样就可以只监视下一个要超时的定时器就可以了。\n而上图还是要监视500个，于是下一步的优化就是记录当前计时器的个数，减少循环，之前还有一步就是尽量减少循环中的计算，包括比较（if语句）尽量减少少数情况的判断，提高速度。 涉及到的主要问题就是速度优化，下面列举一些常用到的比较简单的循环体的优化方式：\n1：将在循环里面多次计算，但是结果不会改变的计算，移到循环外面去。\n2：减少函数调用\n3：减少内存访问\n4：减少对少数特殊情况的测试\n目前就这些，以后用到定时器会继续说。。\n FIFO (2013-12-16 14:57:00) 首先是FIFO缓冲区的一个通用化，这样就相当于在一个队列里面加入了很多中断处理收到的数据，CPU可以根据自己的节奏一个一个来处理，包括鼠标，键盘，定时器，以后还有可能是其他的设备，这样做的好处就是先后顺序很明确，谁先来就先处理谁，如果有多个缓冲区就无法确定哪个应该先处理，哪个应该暂时等待，而且这样设计更有利于编写程序，一举多得。 接着就是比较重要的性能测试，说实话，这个是非常重要而且想让我们的程序飞起来就必须反复去做的，作者也在这方面写了很多，但是方法很简单\n1：写程序，运行，记录时间，观察代码 2：优化代码 3：继续跑程序，记录时间，返回第二步\n什么时候感觉已经很快了，这就算结束了，但是最最最重要的是优化代码，这个一句话两句话根本说不明白，我也是个水菜鸟，所以这里就不瞎说了，大家自己看书学习吧，哈哈，反正觉得效率才是硬道理，效率和稳定，我觉得是核心种的核心，无论什么原因这两个都不能变。 具体方法，作者提到了一个链表，这个就是数据结构的应用，希望以后设计操作系统的时候能用到更多的其他数据结构来优化程序性能\n高分辨率 (2013-12-16 15:21:00) 高分辨率 高分辨率，这个是个必须要说的话题，因为好像没有啥电脑显示器用320*200的分辨率了，所以提高分辨率势在必行。。哈哈 一个重要的操作就是查询VBE 中断编号 0x10 参数ES：DI指向的地址将会被VBE的内容覆盖 参数AX存储一个返回值，如果是0x004f就是有VBE不是这个值，就意味着VBE不可用 画面模式信息：\n WORD 【ES:DI + 0x00】 :模式属性 WORD 【ES:DI + 0x12】 :x分辨率 WORD 【ES:DI + 0x14】 :y分辨率 BYTE 【ES:DI + 0x19】 :颜色数。。。必须为8 BYTE 【ES:DI + 0x1b】 :颜色的指定方法。。。必须为4（4为调色板模式） DWORD 【ES:DI + 0x28】 :VRAM的地址 然后就是现实键盘输入，移动对话框，不在赘述\n多任务 I (2013-12-17 15:20:00) 今天的内容是多任务，所谓多任务就是“同时”执行多个任务，作者写的是在单核cpu上轮流执行多个任务，在短时间进行各种切换，但是实际上还是串联的，虽然表面上看的是同时执行，不知道现在的多核处理器是如何完成多任务的，我一会儿google一下，写出来，应该有很些不同。 先说今天的内容，对于任务切换，处理器是有代价的，也就是说，切来切去是要消耗时钟周期的，例如如果切换一次需要消耗额外的1s但是你每2s切换一次，也就是执行一个任务一共用了3s（因为任务完成后总要切换，所以就可以把切换时间算入总的执行时间）但真正的执行只是2s这样效率只有66.67%如果1s切换一次，就是有50%了。所以几秒切一次很重要，如果10000s切换一次，效率近似与99.99%但是估计使用者会等疯，卡死了。\n上面的1s切换时间是我扯淡的，没有那么慢，书上说千分之一秒，估计现在的处理器会更快。\n重要概念：TSS\nTSS：（Task Status Segment）任务状态段，用于记录任务的执行情况，和已经执行的进度，就像打游戏的读档，就可以直接玩上次存档的地方了，而不是从头接着打，而这个档就是TSS负责记录各种状态（装备等级，任务进度什么乱七八糟的）任务切换时查询TSS然后继续运行。\nCPU特殊机制：执行带有段地址的命令式就会去GDT种查询一下，看是否是另外的程序，如果是，就进行任务切换。\nGDT是个很重要的管理者，应该去画个图把整个体系操作系统体系画出来，这样以后设计的时候就能参考蓝图一步步设计了。看完这本书就去画。\n提高运行速度，其实作者把修改刷新显示频率作为第一步优化，我觉得这个完全在定时器的时候就应该修改系统原始设计，因为屏幕的刷新率一般就那么几种，刷的过快没效果而且消耗资源，过慢当然也不行，既然写到这，那就算优化吧，边做边修改，也是一种好方法，没谁能一开始就制定天衣无缝的计划。。。\n第二点提高速度很精彩，就是把任务切换定时器从缓冲区中分离，也就是键盘，鼠标，普通定时器等中断在FIFO的缓冲区，而任务切换的定时器不在其中，不论其中是否有未处理的中断时间一到，马上切换，但是，问题是，如果FIFO中又任务A的中断处理，但是此时任务A恰好切换到B。。这岂不是坑爹了。。。不太明白，看看查查资料有没有详细的介绍。\n还有就是return不能随便用，在开发系统的时候，还有函数调用时对EFLAG寄存器的影响，都是应该注意的。\n多任务 II (2013-12-19 14:51:00) 今天是多任务第二讲，比昨天的层次更高，更加接近实际使用的设计。\n首先是任务的自动化，所谓任务就是正在执行的程序，程序成千上万，可以自己随意安装，所以，管理就不能靠人工修改代码，而要自动管理，自动分配空间，自动注册相关设置，所以就要建立一个结构体来管理众多任务，记录当前任务的信息。\n任务的休眠，有些任务需要等待数据，或者等待中断程序，等待的时候CPU等就会跟着闲着，这可不好，我们必须让CPU尽可能的处于运行状态，所以就有了任务的休眠，让一个等待的任务不再处于运行状态，而让那些高计算量的任务过来运行，而当任务休眠时，数据到来，马上唤醒任务，让他继续执行。就是这样的。\n接下来就涉及到任务的优先级了，谁应该有更多的系统资源，比如你听音乐和写程序，一输入代码音乐就卡这可不好，分成1，2，3，4，5……12各种等级，我们可以音乐12级，文本编辑5级，这样优先执行音乐，音乐不会卡，文本就算卡也没办法。。自找的。。跟我们音乐大哥抢资源是抢不过滴。\n其实这并不是科学的划分，如果超过12个任务，必然有同级任务存在，那到时候怎么办呢，音乐和电影抢资源，谁应该赢呢，即使这个问题解决了，优先级运行时间划分也存在问题，如果安装1级1s（假设），2级2秒。。。。10级十秒这种划分也不是很科学的，因为2级和1级只差一级，但2级运行时间是1级的一倍，而3级和2级之间也只差一级，但却只有1.5倍所以这也是个问题。。这个姑且放一下，以后再考虑。\n作者解决音乐和电影的方法是把等级再分层，类似与金字塔结构，每层有不同的任务，任务永远只在顶层切换，而不会轮到下层，知道上层都运行结束，也就是顶层消灭了，才会轮到现在的顶层，之前的第二层。而如果高层来人了，当前层当前运行任务结束后，无条件切换到上层。\n都是些理论，不知道现在实际种工作的操作系统是怎么弄得，查到资料了再写出来\n一个半成品 (2014-09-14 22:56:00) 之前看《30天自制操作系统》，参考而成，和书中系统并不完全一致，是在原有基础上按照自己的习惯而成，由于水平和工作原因，未完成内存管理和文件系统，有兴趣者可以通过以下网址https://github.com/TonyTan1991/Jupiter，欢迎留言，欢迎参与项目并改进。 因想寻求图像处理的工作，接下来将开始写作图像处理类博客，内容包括算法原理，实现，OpenCV实现等，欢迎关注\n  川合秀実. 30 日でできる! OS 自作入門. マイナビ出版, 2006. ↩︎\n   ","wordCount":"1006","inLanguage":"en","datePublished":"2013-12-13T14:42:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"谭升"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://go.face2ai.com/%E7%BC%96%E7%A8%8B/30-days/30_days_system/"},"publisher":{"@type":"Organization","name":"谭升的博客","logo":{"@type":"ImageObject","url":"https://go.face2ai.com/logo.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://go.face2ai.com accesskey=h title="谭升的博客 (Alt + H)">谭升的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://go.face2ai.com/math/ title=数学><span>数学</span></a></li><li><a href=https://go.face2ai.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://go.face2ai.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://go.face2ai.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://go.face2ai.com/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://go.face2ai.com>Home</a></div><h1 class=post-title>30天自制操作系统</h1><div class=post-meta><span title="2013-12-13 14:42:00 +0000 UTC">December 13, 2013</span>&nbsp;·&nbsp;谭升</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f1 aria-label=30天自制操作系统1>30天自制操作系统<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></a><ul><li><a href=#mac%e4%b8%8b%e5%b7%a5%e5%85%b7%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=Mac下工具的使用>Mac下工具的使用</a></li><li><a href=#mac%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba-2013-12-13-142000 aria-label="Mac环境搭建 (2013-12-13 14:20:00)">Mac环境搭建 (2013-12-13 14:20:00)</a></li><li><a href=#mac%e7%8e%af%e5%a2%83%e4%b8%8b%e7%9a%84%e5%b7%a5%e5%85%b7%e4%bb%8b%e7%bb%8d-2013-12-09-202000 aria-label="Mac环境下的工具介绍 (2013-12-09 20:20:00)">Mac环境下的工具介绍 (2013-12-09 20:20:00)</a></li><li><a href=#%e4%bf%9d%e6%8a%a4%e6%a8%a1%e5%bc%8f-2013-11-27-165500 aria-label="保护模式 (2013-11-27 16:55:00)">保护模式 (2013-11-27 16:55:00)</a><ul><li><a href=#%e8%bd%af%e7%9b%98%e4%b8%8d%e9%9c%80%e8%a6%81 aria-label=软盘？不需要！>软盘？不需要！</a></li></ul></li><li><a href=#iplbios--2013-11-27-182000 aria-label="IPL，BIOS  (2013-11-27 18:20:00)">IPL，BIOS (2013-11-27 18:20:00)</a><ul><li><a href=#ipl aria-label=IPL>IPL</a></li></ul></li><li><a href=#%e6%b1%87%e7%bc%96%e4%b8%8ec%e8%af%ad%e8%a8%80-2013-11-27-190700 aria-label="汇编与C语言 (2013-11-27 19:07:00)">汇编与C语言 (2013-11-27 19:07:00)</a><ul><li><a href=#%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%87%bd%e6%95%b0%e7%94%a8c%e8%af%ad%e8%a8%80%e8%b0%83%e7%94%a8 aria-label=汇编语言函数用c语言调用>汇编语言函数用c语言调用</a></li></ul></li><li><a href=#gdt%e5%92%8cidt-2013-11-27-201200 aria-label="GDT和IDT (2013-11-27 20:12:00)">GDT和IDT (2013-11-27 20:12:00)</a><ul><li><a href=#gdt%e5%92%8cidt aria-label=GDT和IDT>GDT和IDT</a></li></ul></li><li><a href=#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86--2013-11-28-162000 aria-label="中断处理  (2013-11-28 16:20:00)">中断处理 (2013-11-28 16:20:00)</a><ul><li><a href=#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86 aria-label=中断处理>中断处理</a></li></ul></li><li><a href=#%e4%b8%ad%e6%96%ad-2013-11-29-132300 aria-label="中断 (2013-11-29 13:23:00)">中断 (2013-11-29 13:23:00)</a><ul><li><a href=#%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f aria-label=中断处理程序>中断处理程序</a></li></ul></li><li><a href=#%e9%bc%a0%e6%a0%87--2013-11-30-154400 aria-label="鼠标  (2013-11-30 15:44:00)">鼠标 (2013-11-30 15:44:00)</a><ul><li><a href=#%e5%95%8a%e5%93%88%e9%bc%a0%e6%a0%87 aria-label=啊哈，鼠标>啊哈，鼠标</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86-2013-12-01-134700 aria-label="内存管理 (2013-12-01 13:47:00)">内存管理 (2013-12-01 13:47:00)</a><ul><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label=内存管理>内存管理</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%92%8c%e5%8f%a0%e5%8a%a0%e5%a4%84%e7%90%86-2013-12-02-134200 aria-label="内存管理和叠加处理 (2013-12-02 13:42:00)">内存管理和叠加处理 (2013-12-02 13:42:00)</a><ul><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e5%92%8c%e5%8f%a0%e5%8a%a0%e5%a4%84%e7%90%86 aria-label=内存管理和叠加处理>内存管理和叠加处理</a></li></ul></li><li><a href=#%e5%ae%9a%e6%97%b6%e5%99%a8-2013-12-03-140600 aria-label="定时器 (2013-12-03 14:06:00)">定时器 (2013-12-03 14:06:00)</a><ul><li><a href=#%e9%97%aa%e7%83%81%e5%92%8c%e5%ae%9a%e6%97%b6%e5%99%a8 aria-label=闪烁和定时器>闪烁和定时器</a></li></ul></li><li><a href=#%e8%ae%a1%e6%97%b6%e5%99%a8-2013-12-05-190000 aria-label="计时器 (2013-12-05 19:00:00)">计时器 (2013-12-05 19:00:00)</a><ul><li><a href=#%e8%ae%a1%e6%97%b6%e5%99%a8 aria-label=计时器>计时器</a></li></ul></li><li><a href=#fifo--2013-12-16-145700 aria-label="FIFO  (2013-12-16 14:57:00)">FIFO (2013-12-16 14:57:00)</a></li><li><a href=#%e9%ab%98%e5%88%86%e8%be%a8%e7%8e%87--2013-12-16-152100 aria-label="高分辨率  (2013-12-16 15:21:00)">高分辨率 (2013-12-16 15:21:00)</a><ul><li><a href=#%e9%ab%98%e5%88%86%e8%be%a8%e7%8e%87 aria-label=高分辨率>高分辨率</a></li></ul></li><li><a href=#%e5%a4%9a%e4%bb%bb%e5%8a%a1-i--2013-12-17-152000 aria-label="多任务 I  (2013-12-17 15:20:00)">多任务 I (2013-12-17 15:20:00)</a></li><li><a href=#%e5%a4%9a%e4%bb%bb%e5%8a%a1-ii--2013-12-19-145100 aria-label="多任务 II  (2013-12-19 14:51:00)">多任务 II (2013-12-19 14:51:00)</a></li><li><a href=#%e4%b8%80%e4%b8%aa%e5%8d%8a%e6%88%90%e5%93%81-2014-09-14-225600 aria-label="一个半成品 (2014-09-14 22:56:00)">一个半成品 (2014-09-14 22:56:00)</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=30天自制操作系统1>30天自制操作系统<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><a hidden class=anchor aria-hidden=true href=#30天自制操作系统1>#</a></h1><h2 id=mac下工具的使用>Mac下工具的使用<a hidden class=anchor aria-hidden=true href=#mac下工具的使用>#</a></h2><p>现在来介绍官网上下的工具怎么用首先是官网地址，书上有个注释上有:hrb.osask.jp
<img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131213143501046.png alt=Center>
翻译成中文大概是这个样子滴。</p><p>上面有两个文件可以下载，一个是工具，一个是工具的源代码，很好的学习资料</p><p>下面把工具复制出来</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131213143655937.png alt="Center 1"></p><p>看到很多可执行文件。。感觉好舒服。。</p><p>然后把我们随便一个project复制到z_tools的同级目录下</p><p>project的内容可以修改，因为批处理可以下岗了：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131213143514609.png alt="Center 2"></p><p>然后可能是难度最大的部分出现了:修改makefile</p><p>如果没用过makefile可以先找点资料看看。很简单的语法，很强大的功能：
修改完成后是：</p><pre tabindex=0><code>    TOOLPATH = ../z_tools/
    INCPATH  = ../z_tools/haribote/
    ###################################################     MAKE     = make
    NASK     = $(TOOLPATH)nask
    CC1      = $(TOOLPATH)gocc1 -I$(INCPATH) -Os -Wall -quiet
    GAS2NASK = $(TOOLPATH)gas2nask -a
    OBJ2BIM  = $(TOOLPATH)obj2bim
    BIM2HRB  = $(TOOLPATH)bim2hrb
    RULEFILE = $(TOOLPATH)haribote/haribote.rul
    EDIMG    = $(TOOLPATH)edimg
    IMGTOL   = $(TOOLPATH)imgtol.com
    COPY     = cp
    DEL      = rm
    ###################################################     ## ÉfÉtÉHÉãÉgìÆçÏ

    default :
    	$(MAKE) img

    ## ÉtÉ@ÉCÉãê∂ê¨ãKë•

    ipl10.bin : ipl10.nas Makefile
    	$(NASK) ipl10.nas ipl10.bin ipl10.lst

    asmhead.bin : asmhead.nas Makefile
    	$(NASK) asmhead.nas asmhead.bin asmhead.lst

    bootpack.gas : bootpack.c Makefile
    	$(CC1) -o bootpack.gas bootpack.c

    bootpack.nas : bootpack.gas Makefile
    	$(GAS2NASK) bootpack.gas bootpack.nas

    bootpack.obj : bootpack.nas Makefile
    	$(NASK) bootpack.nas bootpack.obj bootpack.lst

    bootpack.bim : bootpack.obj Makefile
    	$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \
    		bootpack.obj
    ## 3MB+64KB=3136KB

    bootpack.hrb : bootpack.bim Makefile
    	$(BIM2HRB) bootpack.bim bootpack.hrb 0
    ##################################################     haribote.sys : asmhead.bin bootpack.hrb Makefile
    	cat  asmhead.bin bootpack.hrb&gt;haribote.sys
    ###################################################     haribote.img : ipl10.bin haribote.sys Makefile
    	$(EDIMG)   imgin:../z_tools/fdimg0at.tek \
    		wbinimg src:ipl10.bin len:512 from:0 to:0 \
    		copy from:haribote.sys to:@: \
    		imgout:haribote.img

    ## ÉRÉ}ÉìÉh

    img :
    	$(MAKE) haribote.img
    #################################################     run :
    	$(MAKE) img
    	qemu -fda haribote.img
    ###################################################

    clean :
    	-$(DEL) *.bin
    	-$(DEL) *.lst
    	-$(DEL) *.gas
    	-$(DEL) *.obj
    	-$(DEL) bootpack.nas
    	-$(DEL) bootpack.map
    	-$(DEL) bootpack.bim
    	-$(DEL) bootpack.hrb
    	-$(DEL) haribote.sys

    src_only :
    	$(MAKE) clean
    	-$(DEL) haribote.img
</code></pre><p>乱码是原来的日语。。华丽的忽视掉，一排#之间的就是修改过的地方，
然后就是make run了。。
结果如下：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131213144145015.png alt="Center 3"></p><h2 id=mac环境搭建-2013-12-13-142000>Mac环境搭建 (2013-12-13 14:20:00)<a hidden class=anchor aria-hidden=true href=#mac环境搭建-2013-12-13-142000>#</a></h2><p>弄了三天了，终于弄好了，先说结果，就是作者在网站上放了os x的工具（hrb.osask.jp，也有linux下的工具，可以自己去下载），也就是说我白忙活了三天。。。</p><p>再说一下这几天都干啥了，主要是想把c语言和nasm汇编连在一起。这个很多人都做过，但在网上现有的资料很少有在os X上做的的，也或者做了大家都没人说。。。。先贴代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>    <span class=k>extern</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>,</span><span class=kt>int</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    	<span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=n>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span><span class=o>&amp;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    	<span class=k>while</span><span class=p>(</span><span class=n>a</span><span class=o>==</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>这是c代码，调用swap交换两个值，为了不调用标准库，我没写显示函数，而是用了一个死循环代替，如果程序停住了，说明运行成功，再贴下汇编，这是我第一次写汇编哦。。啦啦啦啦啦</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl>    <span class=k>GLOBAL</span> <span class=nv>_swap</span>
</span></span><span class=line><span class=cl>    <span class=err>[</span><span class=k>section</span> <span class=nv>.text</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nl>_swap:</span>
</span></span><span class=line><span class=cl>    	<span class=nf>mov</span> <span class=nb>EDX</span><span class=p>,[</span><span class=nb>ESP</span><span class=o>+</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    	<span class=nf>mov</span> <span class=nb>EAX</span><span class=p>,[</span><span class=nb>ESP</span><span class=o>+</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    	<span class=nf>mov</span> <span class=nb>EBX</span><span class=p>,[</span><span class=nb>EDX</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    	<span class=nf>mov</span> <span class=nb>ECX</span><span class=p>,[</span><span class=nb>EAX</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    	<span class=nf>mov</span> <span class=p>[</span><span class=nb>EDX</span><span class=p>],</span><span class=nb>ECX</span>
</span></span><span class=line><span class=cl>    	<span class=nf>mov</span> <span class=p>[</span><span class=nb>EAX</span><span class=p>],</span><span class=nb>EBX</span>
</span></span><span class=line><span class=cl>    	<span class=nf>ret</span>
</span></span></code></pre></div><p>代码很简单，但是和书上格式有些不同，作者说的他用的是nask是他自己改版的nasm所以有些关键字用不了。。。</p><p>然后是编译成obj文件，这个很纠结，一开始不会用gcc编译出32位obj后来发现要加：</p><pre tabindex=0><code>\-m32 
</code></pre><p>就可以了。</p><p>编译过程如下图：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131213140747343.png alt=Center></p><p>整个编译连接过程，最后光标停止，说明函数执行成功，如果nasm中写了什么中断或者什么其他系统不允许的可能会有总线错误（bus error）或者段错误（详情可以去看《c专家编程》，有相关说明）。
值得注意的是nasm -f 的参数：</p><pre tabindex=0><code>valid output formats for -f are (\`\*&#39; denotes default):

  \* bin       flat-form binary files (e.g. DOS .COM, .SYS)

    aout      Linux a.out object files

    aoutb     NetBSD/FreeBSD a.out object files

    coff      COFF (i386) object files (e.g. DJGPP for DOS)

    elf       ELF32 (i386) object files (e.g. Linux)

    as86      Linux as86 (bin86 version 0.3) object files

    obj       MS-DOS 16-bit/32-bit OMF object files

    win32     Microsoft Win32 (i386) object files

    rdf       Relocatable Dynamic Object File Format v2.0

    ieee      IEEE-695 (LADsoft variant) object file format

    macho     NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X object files
</code></pre><p>这个参数纠结了好久，最后还是看帮助搞定的，因为linux下都是elf，但是os x用elf参数最后ld会报错，说找不到xxx函数定义。。
ld的相关问题：</p><pre tabindex=0><code>1：ld: symbol(s) not found for inferred architecture i386
2：ld: symbol(s) not found for inferred architecture x86\_64
3：ld: warning: ignoring file xxxx.o, file was built for unsupported file format
</code></pre><p>1，2和3的问题原因都是-f参数选的不对，或者gcc编译出来的是64位obj，nasm只能编译出来32或者16位目标代码。</p><p>如果和系统可运行程序不对应，ld不会给你链接的</p><p>最后是objcopy，这个是GNU 的binutils的工具包的一部分。作用是操作二进制文件，可以任意改格式，具体参考说明，吧之前链接好的用objcopy生成纯二进制文件后，和作者的比较发现，不一样，运行时qemu卡死，得到结论就是这两天又白忙活了。还好算是找到了工具，也有源代码，值得好好学习。</p><h2 id=mac环境下的工具介绍-2013-12-09-202000>Mac环境下的工具介绍 (2013-12-09 20:20:00)<a hidden class=anchor aria-hidden=true href=#mac环境下的工具介绍-2013-12-09-202000>#</a></h2><p>这几天一直在搞这个破环境，尝试各种做法，网上各种垃圾信息，浪费了很多时间，说的基本都是废话，不过还是找到了一些，赶紧写下来，不然这个过几天又忘了</p><p>首先是环境，我用的是Max os Maverick 64，就是10.9，硬件（有点低0.0，对于小菜的我已经完全够用啦）：</p><p>10.9刚发布，新出来的东西总问题一大堆，然后解决办法没几个。但是还是能用了，编译器NASM（xcode中command line tools带的那个）xcode真的很大，但是不可否认，安装比vs2010快多了。基本指令是<code>dd</code>指令，和<code>cat</code>指令，这两个和linux下差不多.
首先建立一个.img的镜像文件：</p><pre tabindex=0><code>dd if=xxxxx of=xxxx.img count=20000         
</code></pre><p>注意，if后面的参数是个文件夹，用空的，of参数是输出的img文件 count 是大小，自己十几次就知道了, 然后编写ipl。
注意，后缀用.s而不用nas哦，因为.s的文件vi编辑器会自动语法高亮
然后要说一下ipl中的一句话</p><pre tabindex=0><code>RESB0x7fde-$
</code></pre><p>这句话汇编通不过：提示这一行有非法操作符。。我也不知道咋回事。。。。。
改成：</p><p><img loading=lazy src=./20131209201250890.png alt=Center></p><p>就可以顺利的汇编成bin文件了接着，用CAT指令把bin塞到img中</p><pre tabindex=0><code>cat ill.bin &gt; xxxx.img  
</code></pre><p>然后用qemu执行以下</p><pre tabindex=0><code>qemu -fda xxxx.img                              
</code></pre><p>结果如图：
<img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131209201546875.png alt="Center 1">
用到的工具软件我会上传，安装比较简单，都是dmg的，双击就好。后天继续把c语言弄进来</p><h2 id=保护模式-2013-11-27-165500>保护模式 (2013-11-27 16:55:00)<a hidden class=anchor aria-hidden=true href=#保护模式-2013-11-27-165500>#</a></h2><h3 id=软盘不需要>软盘？不需要！<a hidden class=anchor aria-hidden=true href=#软盘不需要>#</a></h3><p>昨天一天看了5天内容，把觉得有些可能不好理解的写下来，内容不分先后，感觉作者写的通俗易懂，而且代码以及工具在xp下运行流畅，根本不需要软盘，直接在工具提供的虚拟机上跑就可以，下面来描述下昨天的学习心得和问题。</p><p>首先是内存，对内存的管理是至关重要的，所以我们应该先了解一下内存的具体分布:</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131127162257171.bmp alt=Center></p><p>这个图是我找的，如果有打错的地方或者有什么变动，请留言，不胜感激。
这就是内存的分配，对于小菜理解有些困难。接下来可能就是从加电到系统启动的过程的理解了.
实模式下（为保护模式做准备），启动并加载过程如下图：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131127165016359.bmp alt=SouthEast></p><p>至于为什么到0x07c00，原因是“两头约定”（就是设计BIOS的大伯们和设计操作系统的大叔们商量好，把启动程序放那，一后大家开发都方便）。
里面用到的汇编命令，可以去看一些汇编的书，王爽老师的那本书不错，还有《深入理解操作系统》里面的知识和这里用到的也很合拍，都是好书，可以看看。
没有写完，下一篇继续写前五天的。</p><h2 id=iplbios--2013-11-27-182000>IPL，BIOS (2013-11-27 18:20:00)<a hidden class=anchor aria-hidden=true href=#iplbios--2013-11-27-182000>#</a></h2><h3 id=ipl>IPL<a hidden class=anchor aria-hidden=true href=#ipl>#</a></h3><p>其实还是前五天的，现在继续说，第三天，p49页下面部分说“0x8000到0x81ff是启动区”而0x7c00到0x7dff也是启动区，这个地方困扰了我好久，不过今天好像看到类似的说法了:在linux中启动区启动后会将启动区复制到0x90000的地方，原因也没说，知识含糊的说为后面的栈操作做准备，其实无论怎么放，这只是表明，IPL功能已经工作了，成功的实现了转移，我们可以自己来控制电脑了。
在IPL的实现过程中，我发现BIOS中断的威力相当大，就像平时我们用库函数一样，各种寄存器就是这些函数的参数，可以实现硬件的各种操作，准备明天起早找点BIOS中断的资料贴一下，如果能熟练运用会有很牛的感觉，已经接近硬件了，很兴奋。。。汇编是一把利器。</p><h2 id=汇编与c语言-2013-11-27-190700>汇编与C语言 (2013-11-27 19:07:00)<a hidden class=anchor aria-hidden=true href=#汇编与c语言-2013-11-27-190700>#</a></h2><h3 id=汇编语言函数用c语言调用>汇编语言函数用c语言调用<a hidden class=anchor aria-hidden=true href=#汇编语言函数用c语言调用>#</a></h3><p>其实我们可以把这些在完成操作系统编写时写的函数称为库函数（注意：不是标准库函数），但是c在调用库函数（普通函数），压栈的顺序是从右向左的，这个是肯定，所以，参数出栈的时候先出来的是后面的参数，明白了这个问题，就很好理解io_out()函数参数的出栈和参数的使用了，还有函数如果有返回值，保存在eax（32位返回值），64位返回值保存在 eax 和edx中，edx保存高32位，eax保存低32位。</p><p>知道了这些，参数和返回值就已经搞定了，剩下的就是定义和具体代码的实现了，什么利用中断啊，MOV给你MOV给我啊的什么就可以自由发挥了。</p><p>看起来已经很酷了。
函数定义，搜了一下，发现定义都不同，但都是写global声明下函数名（名字前面加下划线），然后以函数名为标号写下函数体，返回用ret（但有些函数好像不能用RET返回。。具体以后再说）。</p><p>还有就是函数指针，由于博主以前研究了好长时间指针，虽然不能说特别明白，但是看这个书上的指针还是没什么障碍，像什么2【p】这种访问方式，以前也都见过，如果有人这里有疑问推荐几本书：《c专家编程》《c陷阱与缺陷》《c和指针》都有详细描述，自己写个程序试试就行了，这里不再赘述。</p><h2 id=gdt和idt-2013-11-27-201200>GDT和IDT (2013-11-27 20:12:00)<a hidden class=anchor aria-hidden=true href=#gdt和idt-2013-11-27-201200>#</a></h2><h3 id=gdt和idt>GDT和IDT<a hidden class=anchor aria-hidden=true href=#gdt和idt>#</a></h3><p>全局描述表（GDT ，Global Descriptor Table）：首先看到全局说明这货很重要，应该是掌握了一些，其次这个表是个数组，所以，这是一个重要的数据结构。</p><p>GDT数组中装的是段描述符【段地址，段的最大长度，访问权限】。因为这个描述符太大了，没有这么大的寄存器（64位），所以就把这个描述符放在内存里，成为了重要的GDT，intel的大叔们设计了一个寄存器GDTR（LGDT为装入此寄存器指令）用来存放GDT的入口地址，因为GDT可以设计到内存的任何位置，而GDTR可以帮助快速定位，这样段寄存器的13位就能索引到GDT了。GDT是保护模式必备的数据结构。能够很好的划分内存，控制程序的内存方位（不然会出大问题）。</p><p>中断描述符表（IDT Interrupt Descriptor Table）：之前已经见识过中断的强大了，这个描述符表是管理中断的，很明显是高手中的高手，其实他是一个8字节的描述符数组，也是一种重要的数据结构。IDT只要保存256个描述符就够了，因为最多也不会有超过256种中断，甚至IDT可以少于256，只要够用就行。同样，IDT可以放在内存的各个角落，只要你愿意，但是一定要是线性的，不然就找不到了（这是个数组，当然线性了），IDT也有专门的寄存器存放入口地址，叫IDTR，这个寄存器中含有IDT表32位的基地址（高32位）和16位的长度（限长）值（低16位）。IDT表基地址应该对齐在8<a href=http://baike.baidu.com/view/60408.htm>字节</a>边界上以提高处理器的访问效率。LIDT和SIDT指令分别用于加载和保存IDTR寄存器的内容。LIDT指令用于把内存中的限长值和基地址操作数加载到IDTR寄存器中。该指令仅能由当前<a href=http://baike.baidu.com/view/2188561.htm>特权级</a>CPL是0的代码执行，通常被用于创建IDT时的操作<a href=http://baike.baidu.com/view/811790.htm>系统初始化</a>代码中。如果有越界访问IDT的现象会触发一个保护性异常。</p><p>中断向量表：实模式下的前1K个字节为中断向量表，每项有四字节（2字节的段地址，2字节的偏移地址，来定位实模式下的1M空间），用来指向中断处理程序的位置，但是在保护模式下，4字节不够用，需要8字节，所以改名IDT，而且位置也不局限于开始的0x00000处，使用全新的方式完成中断处理。</p><p>IDT中的每一项叫“门”（门描述符），很明显是传送门。。哈哈。。</p><h2 id=中断处理--2013-11-28-162000>中断处理 (2013-11-28 16:20:00)<a hidden class=anchor aria-hidden=true href=#中断处理--2013-11-28-162000>#</a></h2><h3 id=中断处理>中断处理<a hidden class=anchor aria-hidden=true href=#中断处理>#</a></h3><p>我感觉中断处理应该是系统底层设计的关键，因为这是在控制硬件，和给c提供接口，如果接口搞不好，一路兵败如山倒</p><p>分割编译其实就是c语言初等知识，就是别写的太乱，每个文件放不同的东西，头文件加以说明和声明，以及一些宏定义或者什么的，可以去查查相关c语言的资料。
今天让我纠结了一下午的东西在p113，也就是调整栈内容，用以组合出GDTR的48位数据那个地方，很纠结，现在来说明一下：</p><p>首先是c语言函数调用时参数传递问题，先从右边开始压栈，直到所有参数完成，但是在CALL的时候还要对CS：EIP进行压栈，这是个啥东西我也不清楚，所以我们可以看到取参数都从【ESP+4】开始取的，取参数的位置是【ESP+4】,【ESP+5】&mldr;.取多少位就一直加加加。还有就是超过8位以上的数据在内存中存放的规律，如果是8位以下的一个内存单元就可以了，但要是16位32位呢，这就涉及到了大端机（Big-endian）和小端机（Little-endian）的区别了，首先我们以0x12345678为例，32的数据存储：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131128160832984.bmp alt=Center>
就是高地址存高位还是低位的区别，不是很好理解，慢慢熟悉就好了，具体机器是大端还是小端写个c程序就行了，用一个联合来测试一下，具体自己发挥，《c语言深度解剖》有相关描述，好多书都提到过。
下面是113页困扰我很久的问题的具体解析：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131128161249109.bmp alt="Center 1">
这就是那个GDT初始化函数调用时栈的内容，首先很纠结的就是栈底在高地址，栈是向下生长的，所以，看着很别扭，还有就是esp（栈顶指针）不是指向第一个参数的，剩下的问题就很好说了，如果要从内存0x02abf8读取两个字节，那么跟着0x2abf8后面的f9会被连带访问而不是f7。。。。。
接下来说PIC，这是个硬件，如果有点电路知识就应该没啥障碍了，是一个存储设备，cpu可以从他取数据，具体怎么去要看这个片子功能的设计和相关信号的传递方法，没有什么需要解释的，设计完全是为了便于开发。
中断程序的制作应该是核心问题，以及缓冲区的使用，明天再说。感谢收看，</p><h2 id=中断-2013-11-29-132300>中断 (2013-11-29 13:23:00)<a hidden class=anchor aria-hidden=true href=#中断-2013-11-29-132300>#</a></h2><h3 id=中断处理程序>中断处理程序<a hidden class=anchor aria-hidden=true href=#中断处理程序>#</a></h3><p>今天看的还是比较顺利，很快一天的就看完了，总结一下今天的主要知识。</p><p>首先是中断处理程序，中断处理程序尽量高效，短小精悍，所以像显示啊什么的操作尽量不再中断处理程序中出现，因为一旦进入中断处理程序，其他中断将会被屏蔽，因为如果不屏蔽就会出现乱套的现象，一个中断还没完另一个已经来了，你说你干不干，干哪个，所以，尽量减少中断处理时间，这样就可以减小中断同时发生而后发生的没办法处理的现象，所以，缓冲区出现了用武之地。</p><p>之前一直不知道缓冲区是干嘛的，今天终于见到其真正的用途了，就是保存中断信息，然后慢慢处理，之后讲到FIFO缓冲区（讲的不严谨点就是队列），队列的大小随意定义，为了减少数据移动，使用了循环队列，高效，但结构里面有一个len用来判断对是否满，可以用头指针和尾指针的位置关系来判断，但没有多大效率上和空间上的区别，所以应该都可以，这里的队列采用数组而不是链表，数组在空间上连续，所以读的速度更快。效率才是硬道理！</p><p>发现了对中断的处理和处理时对下一个中断的到来以及处理安排上是很重要的，需要我们严加设计的，应该也是系统设计的重要部分，还有书中出现的各种编号（像不同端口的地址什么的），不知道具体去哪找，不同的cpu不知道有没有什么区别，这是不是就Intel那个好几千页的手册所要说明的。</p><p>还有就是鼠标和键盘的电路是一个芯片组上的。</p><p>这几天基本都是用c语言设计，感觉只用汇编写了那些最基本的函数，如果系统想要更强大是不是应该多用汇编写点更多的函数以供调用。</p><h2 id=鼠标--2013-11-30-154400>鼠标 (2013-11-30 15:44:00)<a hidden class=anchor aria-hidden=true href=#鼠标--2013-11-30-154400>#</a></h2><h3 id=啊哈鼠标>啊哈，鼠标<a hidden class=anchor aria-hidden=true href=#啊哈鼠标>#</a></h3><p>今天看的有点纠结，因为竟然看困了，很少有这种情况，主要是有好多东西作者并没有做深入介绍，只是说这样是对的，至于为啥这样以后再说，这让我感觉很不爽。具体来说说。</p><p>首先，先解决了鼠标运动的问题，我感觉这个不是什么大问题，只是读取数据那需要点技巧，就是验证数据的有效性，以前用单片机发送串口数据时也用到过类似的做法，作者提出的是检查第一个字的低八位以及高两位，如果高两位是0，而低八位是8，那么数据没问题，但并不一定绝对没问题，比如发送的数据为 0x08 0x00 0x11下一组为0x08 0x08 0x01时也就是队列里面是0x08 0x00 0x11 0x08 0x08 0x01时如果红色字体丢失任意一组数据，其结果和下一组结果都是错误的，但发生的概率很小，我们也没必要要求硬件每发送一个数据都要加上校验位，那样冗余太大，也浪费资源，而且估计鼠标也不会总坏。</p><p>个人来讲，我不想将桌面作为系统开发的前期所应该做的（等我自己写的时候不会这么弄），一个黑漆漆的命令行而具有更强大的功能，我觉得更好，而且将桌面和系统剥离开，也就是linux那样，感觉更加自由。哈哈，这都是自己的想法，没有任何科学根据。接下来就到了让我纠结的地方了，就是作者解释了之前没解释的汇编代码：</p><pre tabindex=0><code>    ; haribote-os boot asm
    ; TAB=4

    BOTPAK	EQU		0x00280000		; c语言编写部分的入口位置
    DSKCAC	EQU		0x00100000		; 启动区将要被复制到的地方
    DSKCAC0	EQU		0x00008000		; dskcaco启动区存储地址，其实里面没啥，知识为了预留，这也是之前纠结的地方

    ; BOOT_INFO関係
    CYLS	EQU		0x0ff0			;
    LEDS	EQU		0x0ff1
    VMODE	EQU		0x0ff2			;
    SCRNX	EQU		0x0ff4			;
    SCRNY	EQU		0x0ff6			;
    VRAM	EQU		0x0ff8			;

    		ORG		0xc200			;

    ; 显示设置，中断号10H具体中断用法参照google

    MOV		AL,0x13			;
    		MOV		AH,0x00
    		INT		0x10
    		MOV		BYTE [VMODE],8	;
    		MOV		WORD [SCRNX],320
    		MOV		WORD [SCRNY],200
    		MOV		DWORD [VRAM],0x000a0000

    ; 设置键盘中断，中断号16H，自行百度

    		MOV		AH,0x02
    		INT		0x16 			; keyboard BIOS
    		MOV		[LEDS],AL

    ;
    ;	PIC必须在CLI之前设置好
    ;	有些机型不能连续使用OUT指令，中间要停一下
    ;	PIC初始化

    ; CLI指令后CPU屏蔽所有中断

    		MOV		AL,0xff
    		OUT		0x21,AL
    		NOP						;
    		OUT		0xa1,AL

    		CLI						;

    ; 开启A20设置，这里的具体原理见下文。。

    		CALL	waitkbdout
    		MOV		AL,0xd1
    		OUT		0x64,AL
    		CALL	waitkbdout
    		MOV		AL,0xdf			; enable A20
    		OUT		0x60,AL
    		CALL	waitkbdout

    ; 这就是个简单设置并等待反馈的过程，书上说可以同时读取鼠标和键盘。。。我没看出来

    [INSTRSET &#34;i486p&#34;]				; 指令集，不知道酷睿2应该咋表示0.0

    		LGDT	[GDTR0]			; 设定GDT
    		MOV		EAX,CR0
    		AND		EAX,0x7fffffff	;
    		OR		EAX,0x00000001	; 将EAX设置成二进制 1xxx xxxx xxxx xxxx xxxx xxxx xxxx xxx1的形式
    		MOV		CR0,EAX ；CR0很高端的寄存器，只有操作系统可以使用
    		JMP		pipelineflush
    pipelineflush:
    		MOV		AX,1*8			;  1*8不知道是啥意思。。。。。
    		MOV		DS,AX
    		MOV		ES,AX
    		MOV		FS,AX
    		MOV		GS,AX
    		MOV		SS,AX

    ; bootpack

    		MOV		ESI,bootpack	 ; 复制的原始地址
    		MOV		EDI,BOTPAK		; 复制的目标地址
    		MOV		ECX,512*1024/4 ；DWORD是单位
    		CALL	memcpy



    		MOV		ESI,0x7c00		; 同上
    		MOV		EDI,DSKCAC		; 同上
    		MOV		ECX,512/4
    		CALL	memcpy

    ; 残り全部

    		MOV		ESI,DSKCAC0+512	;
    		MOV		EDI,DSKCAC+512	;
    		MOV		ECX,0
    		MOV		CL,BYTE [CYLS]
    		IMUL	 ECX,512*18*2/4	;
    		SUB		ECX,512/4	; 真心不知道这步干啥用
    		CALL	memcpy


    ; bootpack开启
    		MOV		EBX,BOTPAK
    		MOV		ECX,[EBX+16]
    		ADD		ECX,3			; ECX += 3;
    		SHR		ECX,2			; ECX /= 4;
    		JZ		skip			; 如果哦ECX&gt;&gt;2==0，则跳转
    		MOV		ESI,[EBX+20]	; 还是复制。。
    		ADD		ESI,EBX
    		MOV		EDI,[EBX+12]	;
    		CALL	memcpy
    skip:
    		MOV		ESP,[EBX+12]	; 不懂在干啥。。。
    		JMP		DWORD 2*8:0x0000001b

    waitkbdout:
    		IN		 AL,0x64
    		AND		 AL,0x02
    		JNZ		waitkbdout		; 读入0x64的响应和0x02做与运算，非零则跳转

    RET

    memcpy:
    		MOV		EAX,[ESI]
    		ADD		ESI,4
    		MOV		[EDI],EAX
    		ADD		EDI,4
    		SUB		ECX,1
    		JNZ		memcpy			; 复制过程比较简单
    		RET


    		ALIGNB	16
    GDT0:
    		RESB	8				;
    		DW		0xffff,0x0000,0x9200,0x00cf	;
    		DW		0xffff,0x0000,0x9a28,0x0047	; 不知道在干嘛。。写了这么多奇怪的地址

    		DW		0
    GDTR0:
    		DW		8*3-1 ；依旧不知道8*3哈意思
    		DD		GDT0

    		ALIGNB	16
    bootpack:
</code></pre><p>好吧，我的理解就只能到上面这个地步，不知道再继续往下看还能多领悟点不了。</p><p>为什么是向键盘发送指令来控制A20GATE呢？百度到的原因是为了控制是否使用超过1M以上的内存，并和16位兼容，IBM的老爷爷们使用键盘控制器剩下的一根信号线来控制A20，A20不是控制是否进入保护模式。</p><p>原始16位处理器访问最高地址为0xFFFF：0xFFFF=0xFFFF0+0xFFFF=0x10EFFEF,很明显多于1M对于多出来的0xEFFEF的访问就需要另外的地址线。但是系统的做法是当程序员访问多于1M的地址时，CPU将地址按1M取模。。这样就不会超过1M了，这种技术被称为wrap-around</p><p>到了80286出现了一些问题，当程序员试图访问1M到0x10EFFEF时系统并没有循环回去而是直接访问，这导致了和之前产品不兼容，于是为了兼容，设计了第21根信号线就是上面提到的键盘控制器多余的这根，称为A20来控制是否访问1M以后的地址，当设置为打开时可以访问到多于1M的地址，关闭时则只能循环回0按8086的方式访问。</p><p>以上都是实模式下的，在保护模式下，CPU访问的内存增加，如果这个20位的控制线不被打开，那我们的第20号位地址将被视为无效，内存将会被切割成小碎片，系统将只能访问以基数兆的内存。。所以必须要打开A20才能完整访问。至于A20和键盘的关系。就是没啥关系，只不过用一个控制器。
一下内容来自互联网（没有验证准确性）：</p><blockquote><p>多数PC都使用键盘控制器（8042芯片）来处理A20Gate。 从理论上讲，打开A20Gate的方法是通过设置8042芯片输出端口（64h）的2nd-bit，但事实上，当你向8042芯片输出端口进行写操作的时候，在键盘缓冲区中，或许还有别的数据尚未处理，因此你必须首先处理这些数据。 流程如下： 　</p><ol><li>禁止中断； 　</li><li>等待，直到8042 Inputbuffer为空为止；</li><li>发送禁止键盘操作命令到8042Input buffer；</li><li>等待，直到8042 Inputbuffer为空为止；</li><li>发送读取8042 OutputPort命令；</li><li>等待，直到8042 Outputbuffer有数据为止；</li><li>读取8042 Outputbuffer，并保存得到的字节；</li><li>等待，直到8042 Inputbuffer为空为止；</li><li>发送Write 8042Output Port命令到8042 Input buffer； 　</li><li>等待，直到8042 Inputbuffer为空为止； 　</li><li>将从8042 OutputPort得到的字节的第2位置1（OR 2），然后写入8042 Input buffer； 　</li><li>等待，直到8042 Inputbuffer为空为止； 　</li><li>发送允许键盘操作命令到8042Input buffer； 　</li><li>打开中断。</li></ol></blockquote><h2 id=内存管理-2013-12-01-134700>内存管理 (2013-12-01 13:47:00)<a hidden class=anchor aria-hidden=true href=#内存管理-2013-12-01-134700>#</a></h2><h3 id=内存管理>内存管理<a hidden class=anchor aria-hidden=true href=#内存管理>#</a></h3><p>对于一个系统来说，资源是最重要的，管理资源应该说就像计划你口袋里面的钱怎么花一样（不太准确。。但是重要性是相似的）。</p><p>首先是检查内存大小，BIOS应该是提供内存大小检查功能的，但是不同的BIOS查找内存大小的方式不同，所以我们应该以一种更为通用的方法进行，以获得更好的系统兼容性，而且现在的CPU都配有各种缓存，一级，二级，三级。。。先要禁止高速缓存，才能确保访问的变量全部在内存中，所以，先禁用缓存（设置CR0的某个标志位为指定值，本书还检查了一下机器是否有高速缓存，这个现在基本不用检查了，我还真就没见过386长什么样）。禁用掉高速缓存我们就要对内存挨个访问了，看看到底有没有这个位置，对0xaa55aa55的反转和比较再反转，我感觉没有什么具体意义，你可以改成任意的数字，如果访问的内存地址不存在，则返回记录到的最大的位置值，后面的程序是优化次功能程序，如果只为了检查内存的大小，完全可不用一个一个来，而是十个十个来或者一万个一万个来，只检查最后的几位就行，这个的速度会按照相应的倍数提升而准确度也会随之下降。如果要做内存健康检查就要一个一个来了。书中还有一个涉及到编译器的优化问题，这个会在后续的博客中详细介绍。</p><p>接下来，检查完内存就要对内存分配进行管理了，这个应该是个很困难的问题，书中的方法有两种。</p><p>第一种：首先设置内存分配的最小单位，书中为4KB，把所有能用的字节都统计出来划分成4KB一段的好多个内存块，然后用一个字符数组来记录那些很忙，那些很闲，然后分配给需要的程序，这样的代价是每4K就需要8BIT的空间来标记这块的可用性（8/（4×1024）=1/512）所以代价是恒定的，不论多大内存N GB，都需要（N/512GB的内存来记录），这样的好处也是第二种方法的缺点就是不用做拼接，碎片问题容易解决。据说内存碎片是个很可怕的问题，尤其是对于长时间运行的服务器。</p><p>第二种：用一个数据结构记录所有内存的使用情况，这个数据结构内包含一个可用空间大小的记录，还有就是N个用于记录内存起始地址和可用大小的子结构数组了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>FREEINFO</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>addr</span><span class=p>,</span> <span class=n>size</span><span class=p>;</span><span class=c1>//起始地址，和大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>MEMMAN</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    	<span class=kt>int</span> <span class=n>frees</span><span class=p>,</span> <span class=n>maxfrees</span><span class=p>,</span> <span class=n>lostsize</span><span class=p>,</span> <span class=n>losts</span><span class=p>;</span>	   	<span class=c1>//这是内存的一些记录，包括可用空间，最大可用空间，释放失败大小，释放失败的次数
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=k>struct</span> <span class=nc>FREEINFO</span> <span class=n>free</span><span class=p>[</span><span class=n>MEMMAN_FREES</span><span class=p>];</span>        	<span class=c1>//具体的信息。。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span></code></pre></div><p>第二种方法速度快，占用空间小，但是分配时产生的细小的内存空间没有被使用，和回收内存时的合并操作都相当麻烦。。所以有利有弊，当内存碎片过多，而系统回收算法不够强壮时有可能是灾难性的。</p><p>至于设计系统时用什么样的内存管理方法，目前还没想好，总之，这是个很关键的问题。会找一些资料，在后续的博文中陆续推出，欢迎收看</p><h2 id=内存管理和叠加处理-2013-12-02-134200>内存管理和叠加处理 (2013-12-02 13:42:00)<a hidden class=anchor aria-hidden=true href=#内存管理和叠加处理-2013-12-02-134200>#</a></h2><h3 id=内存管理和叠加处理>内存管理和叠加处理<a hidden class=anchor aria-hidden=true href=#内存管理和叠加处理>#</a></h3><p>今天的代码比较多，对于写过程序的人来说应该还是比较容易看懂的。
首先说的内存管理，昨天说道把很多内存分成0x1000字节大小的块，然后分配给程序使用，但是不一定所有的程序用到的都是0x1000的整数倍字节，所以就要设计一个取整的方法，就有了书中提到的聪明做法（size+0xfff）&amp;0xfffff000;这个做法或者称为算法的正确性证明很简单，带两个数试一下就知道玄机了，就是把一个12位非零二进制数向前进位，而零不进位，最后把后3位归零。我们还可以把大于x的任何数进位，小于等于x的舍去（size+0x1000-x-1）&0xfffff000；哈哈，应该是对的，我也没有证明。不过x=0是和原式一样的。举一反三山寨之本。</p><p>接着就到了我很疑惑的地方了。叠加处理，但是！！！注意！！！作者开始给结构体显示的分配内存了，就是图层的控制结构体，我不明白，之前写的那些结构体也没分配内存，为啥突然从这开始分配了，而作者根本没提，难道是因为昨天才写的内存管理，今天就开始用了？那之前的程序怎么办呢。我一会儿还是好好研究一下。</p><p>感觉要设计系统，就应该对这个系统的宏观结构应该完全清楚，骨架清晰，内容就可以随意发挥了。现在是骨架还没搞清楚，所以博猪没有一开始就写自己山寨版，而是想把书看完，然后找点操作系统相关的书再看看然后再做个试验品出来玩玩。。哈哈。。不知道思路正确不正确。。</p><p>至于这个叠加处理，其基本目的是控制多个图层，设计相应的数据结构。而刷新那里作者反复的实验，但其本质就是减少冗余计算，就是说有些计算能剩就不做，就像一个简单的图像卷积（好吧，博猪以前做过一段时间图像处理，听不懂的可以完全忽略。。）如果按照算法做，时间复杂度是 $O(x<em>y</em>size<em>size)$（x，y是图像的大小 $x</em>y$ 个像素，size是卷积核宽度），但经过优化可以做到只要 $O(x*y)$ ，而方法就是要用到前一步的计算结果，减少冗余的计算量（好吧，这是博猪第一次面试的面试题，很幸运。公司没要我0.0）。好，叠加的优化原理是哪个地方改变了，就刷新改变的区域的像素。至于实现细节，书中的代码有详细介绍，关键是确定叠加区域，然后重绘叠加区域。。。 
明天继续努力。</p><h2 id=定时器-2013-12-03-140600>定时器 (2013-12-03 14:06:00)<a hidden class=anchor aria-hidden=true href=#定时器-2013-12-03-140600>#</a></h2><h3 id=闪烁和定时器>闪烁和定时器<a hidden class=anchor aria-hidden=true href=#闪烁和定时器>#</a></h3><p>今天的主要内容是屏幕刷时的闪烁问题，和定时器的小部分内容。</p><p>首先说明定时器应该是系统重要部分，所以明天会好好记录一下计时器的心得。</p><p>关于屏幕刷新时闪烁，这个之前也遇到过（之前做单片机数据绘图时，因为单位时间数据量很大，一直刷新画面就会导致波形图闪烁，而解决这个问题的方法是使用双缓存技术），而这次不同的是如果系统桌面都闪烁，就没人会使用我们的系统了。。所以问题很严重，需要马上解决，作者的解决方法是改变刷新的范围和层数，减少无谓的刷新。其实作者从开始所提出的桌面显示的完整体系就是一种最简单的设计（作者想带着我们一步一步走向高端，但如果看完全书后再去写的话就不需要走弯路了），我们设计时完全可以自己发挥，设计出更高效更华丽的桌面环境，作者最后提到的在内存中开辟map区域其实就是一种高效的方法，而这个方法可以在一开始显示的时候就设计进去，所以，桌面显示并不应该成为我们学习的重点（在系统体系完成后再详细设计规划）。</p><p>相反，计时器才是我们应该好好研究的，这是系统的根本之一。</p><h2 id=计时器-2013-12-05-190000>计时器 (2013-12-05 19:00:00)<a hidden class=anchor aria-hidden=true href=#计时器-2013-12-05-190000>#</a></h2><h3 id=计时器>计时器<a hidden class=anchor aria-hidden=true href=#计时器>#</a></h3><p>昨天一直在搭建环境，想在mac下实现书上制作镜像和编译连接相关文件的功能，无奈，弄了一天还是不太好用，看到另外一个微博上的童鞋用Linux完成了相关操作，想试一下，但os x上没有objcopy等命令，而且gcc好像也是改版的，而且现在被我折腾的连命令行下使用command line tools 都有问题，所以，我还是回来把笔记补上。一会儿再去弄，争取放假之前能把环境搞定，这样寒假就可以专心研制自己的系统了，而不用把时间花到细枝末节上。</p><p>昨天的内容讲的是计时器，我一开始没觉得定时器有啥功能，无非是弄个钟表出来，后来我看到了超时（timeout）恍然觉得这个东西很主要，作者并没有直接说去定时器在以后的实现中有什么作用，但是一直对中断处理程序进行优化可以看出，这个东西以后要被不停地使用，而且作者提出定时器后，马上有多弄了几个，而且最多能实现500个定时器，第十二天的主要工作就是优化处理速度，因为中断处理时所有的中断信号都被屏蔽了，所以必须快速的处理，恢复中断响应。</p><p>下面的图是作者最开始的设计：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131205183342515.jpeg alt=Center></p><p>其中条状的是定时器的执行时间，横坐标是时间，纵坐标是各定时器，不论有多少个定时器，都要循环500次（也就是最多个的情况），所以这对要求效率的工作并不是个好主意，于是开始优化。</p><p>首先可以将定时器排队，就像我们有两场球赛在不同的频道，一个十分钟后在c1频道，一个二十分钟后在c2频道，我们只要盯着那个十分钟后开始的c1频道就可以了，你可以每两分钟过来看一下，如果c1开始了，我们才会去关注c2是否开始（寝室有一哥们能同时看三场球。。。。）也就是说c1不发生，理论上来说c2绝不会发生，所以就优化出了下图：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Tony-Tan/picgo_images_bed/master/uPic/20131205184414062.jpeg alt="Center 1"></p><p>上图横轴是时间，没有纵轴，每个小格子就是不同的定时器之间的间隔，每个定时器都是从头开始到对应的线，也就是把所有定时器从小到大排列起来，然后弄到一根轴上，这样就可以只监视下一个要超时的定时器就可以了。</p><p>而上图还是要监视500个，于是下一步的优化就是记录当前计时器的个数，减少循环，之前还有一步就是尽量减少循环中的计算，包括比较（if语句）尽量减少少数情况的判断，提高速度。
涉及到的主要问题就是速度优化，下面列举一些常用到的比较简单的循环体的优化方式：</p><p><em><strong>1：将在循环里面多次计算，但是结果不会改变的计算，移到循环外面去。</strong></em></p><p><em><strong>2：减少函数调用</strong></em></p><p><em><strong>3：减少内存访问</strong></em></p><p><em><strong>4：减少对少数特殊情况的测试</strong></em></p><p>目前就这些，以后用到定时器会继续说。。</p><p>      </p><h2 id=fifo--2013-12-16-145700>FIFO (2013-12-16 14:57:00)<a hidden class=anchor aria-hidden=true href=#fifo--2013-12-16-145700>#</a></h2><p>首先是FIFO缓冲区的一个通用化，这样就相当于在一个队列里面加入了很多中断处理收到的数据，CPU可以根据自己的节奏一个一个来处理，包括鼠标，键盘，定时器，以后还有可能是其他的设备，这样做的好处就是先后顺序很明确，谁先来就先处理谁，如果有多个缓冲区就无法确定哪个应该先处理，哪个应该暂时等待，而且这样设计更有利于编写程序，一举多得。
接着就是比较重要的性能测试，说实话，这个是非常重要而且想让我们的程序飞起来就必须反复去做的，作者也在这方面写了很多，但是方法很简单</p><p>1：写程序，运行，记录时间，观察代码
2：优化代码
3：继续跑程序，记录时间，返回第二步</p><p>什么时候感觉已经很快了，这就算结束了，但是最最最重要的是优化代码，这个一句话两句话根本说不明白，我也是个水菜鸟，所以这里就不瞎说了，大家自己看书学习吧，哈哈，反正觉得效率才是硬道理，效率和稳定，我觉得是核心种的核心，无论什么原因这两个都不能变。
具体方法，作者提到了一个链表，这个就是数据结构的应用，希望以后设计操作系统的时候能用到更多的其他数据结构来优化程序性能</p><h2 id=高分辨率--2013-12-16-152100>高分辨率 (2013-12-16 15:21:00)<a hidden class=anchor aria-hidden=true href=#高分辨率--2013-12-16-152100>#</a></h2><h3 id=高分辨率>高分辨率<a hidden class=anchor aria-hidden=true href=#高分辨率>#</a></h3><p>高分辨率，这个是个必须要说的话题，因为好像没有啥电脑显示器用320*200的分辨率了，所以提高分辨率势在必行。。哈哈
一个重要的操作就是查询VBE
中断编号 0x10
参数ES：DI指向的地址将会被VBE的内容覆盖
参数AX存储一个返回值，如果是0x004f就是有VBE不是这个值，就意味着VBE不可用
画面模式信息：</p><pre tabindex=0><code>       WORD  【ES:DI + 0x00】       :模式属性    
       WORD  【ES:DI + 0x12】       :x分辨率      
       WORD  【ES:DI + 0x14】       :y分辨率      
       BYTE  【ES:DI + 0x19】       :颜色数。。。必须为8
       BYTE  【ES:DI + 0x1b】         :颜色的指定方法。。。必须为4（4为调色板模式）
       DWORD  【ES:DI + 0x28】    :VRAM的地址     
</code></pre><p>然后就是现实键盘输入，移动对话框，不在赘述</p><h2 id=多任务-i--2013-12-17-152000>多任务 I (2013-12-17 15:20:00)<a hidden class=anchor aria-hidden=true href=#多任务-i--2013-12-17-152000>#</a></h2><p>今天的内容是多任务，所谓多任务就是“同时”执行多个任务，作者写的是在单核cpu上轮流执行多个任务，在短时间进行各种切换，但是实际上还是串联的，虽然表面上看的是同时执行，不知道现在的多核处理器是如何完成多任务的，我一会儿google一下，写出来，应该有很些不同。
先说今天的内容，对于任务切换，处理器是有代价的，也就是说，切来切去是要消耗时钟周期的，例如如果切换一次需要消耗额外的1s但是你每2s切换一次，也就是执行一个任务一共用了3s（因为任务完成后总要切换，所以就可以把切换时间算入总的执行时间）但真正的执行只是2s这样效率只有66.67%如果1s切换一次，就是有50%了。所以几秒切一次很重要，如果10000s切换一次，效率近似与99.99%但是估计使用者会等疯，卡死了。</p><p>上面的1s切换时间是我扯淡的，没有那么慢，书上说千分之一秒，估计现在的处理器会更快。</p><p>重要概念：TSS</p><p>TSS：（Task Status Segment）任务状态段，用于记录任务的执行情况，和已经执行的进度，就像打游戏的读档，就可以直接玩上次存档的地方了，而不是从头接着打，而这个档就是TSS负责记录各种状态（装备等级，任务进度什么乱七八糟的）任务切换时查询TSS然后继续运行。</p><p>CPU特殊机制：执行带有段地址的命令式就会去GDT种查询一下，看是否是另外的程序，如果是，就进行任务切换。</p><p>GDT是个很重要的管理者，应该去画个图把整个体系操作系统体系画出来，这样以后设计的时候就能参考蓝图一步步设计了。看完这本书就去画。</p><p>提高运行速度，其实作者把修改刷新显示频率作为第一步优化，我觉得这个完全在定时器的时候就应该修改系统原始设计，因为屏幕的刷新率一般就那么几种，刷的过快没效果而且消耗资源，过慢当然也不行，既然写到这，那就算优化吧，边做边修改，也是一种好方法，没谁能一开始就制定天衣无缝的计划。。。</p><p>第二点提高速度很精彩，就是把任务切换定时器从缓冲区中分离，也就是键盘，鼠标，普通定时器等中断在FIFO的缓冲区，而任务切换的定时器不在其中，不论其中是否有未处理的中断时间一到，马上切换，但是，问题是，如果FIFO中又任务A的中断处理，但是此时任务A恰好切换到B。。这岂不是坑爹了。。。不太明白，看看查查资料有没有详细的介绍。</p><p>还有就是return不能随便用，在开发系统的时候，还有函数调用时对EFLAG寄存器的影响，都是应该注意的。</p><h2 id=多任务-ii--2013-12-19-145100>多任务 II (2013-12-19 14:51:00)<a hidden class=anchor aria-hidden=true href=#多任务-ii--2013-12-19-145100>#</a></h2><p>今天是多任务第二讲，比昨天的层次更高，更加接近实际使用的设计。</p><p>首先是任务的自动化，所谓任务就是正在执行的程序，程序成千上万，可以自己随意安装，所以，管理就不能靠人工修改代码，而要自动管理，自动分配空间，自动注册相关设置，所以就要建立一个结构体来管理众多任务，记录当前任务的信息。</p><p>任务的休眠，有些任务需要等待数据，或者等待中断程序，等待的时候CPU等就会跟着闲着，这可不好，我们必须让CPU尽可能的处于运行状态，所以就有了任务的休眠，让一个等待的任务不再处于运行状态，而让那些高计算量的任务过来运行，而当任务休眠时，数据到来，马上唤醒任务，让他继续执行。就是这样的。</p><p>接下来就涉及到任务的优先级了，谁应该有更多的系统资源，比如你听音乐和写程序，一输入代码音乐就卡这可不好，分成1，2，3，4，5&mldr;&mldr;12各种等级，我们可以音乐12级，文本编辑5级，这样优先执行音乐，音乐不会卡，文本就算卡也没办法。。自找的。。跟我们音乐大哥抢资源是抢不过滴。</p><p>其实这并不是科学的划分，如果超过12个任务，必然有同级任务存在，那到时候怎么办呢，音乐和电影抢资源，谁应该赢呢，即使这个问题解决了，优先级运行时间划分也存在问题，如果安装1级1s（假设），2级2秒。。。。10级十秒这种划分也不是很科学的，因为2级和1级只差一级，但2级运行时间是1级的一倍，而3级和2级之间也只差一级，但却只有1.5倍所以这也是个问题。。这个姑且放一下，以后再考虑。</p><p>作者解决音乐和电影的方法是把等级再分层，类似与金字塔结构，每层有不同的任务，任务永远只在顶层切换，而不会轮到下层，知道上层都运行结束，也就是顶层消灭了，才会轮到现在的顶层，之前的第二层。而如果高层来人了，当前层当前运行任务结束后，无条件切换到上层。</p><p>都是些理论，不知道现在实际种工作的操作系统是怎么弄得，查到资料了再写出来</p><h2 id=一个半成品-2014-09-14-225600>一个半成品 (2014-09-14 22:56:00)<a hidden class=anchor aria-hidden=true href=#一个半成品-2014-09-14-225600>#</a></h2><p>之前看《30天自制操作系统》，参考而成，和书中系统并不完全一致，是在原有基础上按照自己的习惯而成，由于水平和工作原因，未完成内存管理和文件系统，有兴趣者可以通过以下网址<a href=https://github.com/TonyTan1991/Jupiter>https://github.com/TonyTan1991/Jupiter</a>，欢迎留言，欢迎参与项目并改进。
因想寻求图像处理的工作，接下来将开始写作图像处理类博客，内容包括算法原理，实现，OpenCV实现等，欢迎关注</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>川合秀実. 30 日でできる! OS 自作入門. マイナビ出版, 2006.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://go.face2ai.com/%E7%BC%96%E7%A8%8B/cuda/cuda-f-0-0-tencent-gpu-cloud.zh/><span class=title>« Prev</span><br><span>【CUDA 基础】0.0 腾讯云CUDA环境搭建</span></a>
<a class=next href=https://go.face2ai.com/%E7%BC%96%E7%A8%8B/crawler/crawler/><span class=title>Next »</span><br><span></span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 30天自制操作系统 on twitter" href="https://twitter.com/intent/tweet/?text=30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 30天自制操作系统 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f&title=30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&summary=30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&source=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 30天自制操作系统 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f&title=30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 30天自制操作系统 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 30天自制操作系统 on whatsapp" href="https://api.whatsapp.com/send?text=30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%20-%20https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 30天自制操作系统 on telegram" href="https://telegram.me/share/url?text=30%e5%a4%a9%e8%87%aa%e5%88%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&url=https%3a%2f%2fgo.face2ai.com%2f%25E7%25BC%2596%25E7%25A8%258B%2f30-days%2f30_days_system%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://go.face2ai.com>谭升的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>